<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Language · LearningJulia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LearningJulia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">General</span><ul><li class="is-active"><a class="tocitem" href>Language</a><ul class="internal"><li><a class="tocitem" href="#General-observations"><span>General observations</span></a></li><li class="toplevel"><a class="tocitem" href="#Reading-through-the-Julia-Language-Manual"><span>Reading through the Julia Language Manual</span></a></li><li><a class="tocitem" href="#Variable-Scope"><span>Variable Scope</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Control-Flow"><span>Control Flow</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../ecosystem/">Ecosystem</a></li><li><a class="tocitem" href="../dev_env/">Development Environment</a></li><li><a class="tocitem" href="../documentation/">Documentation</a></li></ul></li><li><span class="tocitem">Software Development</span><ul><li><a class="tocitem" href="../databases/">Databases</a></li><li><a class="tocitem" href="../orm/">Object-Relational Mapping</a></li><li><a class="tocitem" href="../web/">Web Development</a></li></ul></li><li><span class="tocitem">Data Science</span><ul><li><a class="tocitem" href="../dataframes/">Data Frames</a></li><li><a class="tocitem" href="../computation/">Computation</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li></ul></li><li><span class="tocitem">Interoperability</span><ul><li><a class="tocitem" href="../python/">Python</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../smart_home/">Smart Home</a></li><li><a class="tocitem" href="../blogging/">Blogging</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">General</a></li><li class="is-active"><a href>Language</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Language</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tjpalanca/LearningJulia.jl/blob/master/docs/src/language.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-Language"><a class="docs-heading-anchor" href="#Julia-Language">Julia Language</a><a id="Julia-Language-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Language" title="Permalink"></a></h1><ul><li><a href="#Julia-Language">Julia Language</a></li><ul><li><a href="#General-observations">General observations</a></li></ul><li><a href="#Reading-through-the-Julia-Language-Manual">Reading through the Julia Language Manual</a></li><ul><li><a href="#Variable-Scope">Variable Scope</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Control-Flow">Control Flow</a></li><li><a href="#Types">Types</a></li><li><a href="#Methods">Methods</a></li></ul></ul><h2 id="General-observations"><a class="docs-heading-anchor" href="#General-observations">General observations</a><a id="General-observations-1"></a><a class="docs-heading-anchor-permalink" href="#General-observations" title="Permalink"></a></h2><ul><li>I love the named slurping and splatting, an improvement of the R syntax</li><li>It looks like math! Very little cognitive load on translating some work.</li><li>However, the whole multiple dispatch thing, when I watch videos looks amazing, but when I try to implement makes my brain hurt. I suffer from the curse of seeing OOP in Python and R6 in R. S3 is quite similar but is so much  simpler because it&#39;s single dispatch.</li><li>Symbols and strings are separate - amaze! Metaprogramming has been something  that is quite easy in R and I suspect quite easy in Julia too with the macros.</li><li>Do-block syntax - interesting, the function is first and then the iterable in  Julia&#39;s <code>map()</code> as opposed to R&#39;s <code>purrr::map()</code>.</li><li>There&#39;s a lot of reference to language design here and I feel like I&#39;m also learning about it as I read through how to actually use Julia.</li></ul><h1 id="Reading-through-the-Julia-Language-Manual"><a class="docs-heading-anchor" href="#Reading-through-the-Julia-Language-Manual">Reading through the Julia Language Manual</a><a id="Reading-through-the-Julia-Language-Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-through-the-Julia-Language-Manual" title="Permalink"></a></h1><h2 id="Variable-Scope"><a class="docs-heading-anchor" href="#Variable-Scope">Variable Scope</a><a id="Variable-Scope-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Scope" title="Permalink"></a></h2><ul><li>Global and local scope</li><li><code>if</code> and <code>begin/end</code> blocks do not introduce new scopes</li><li>Julia uses <em>lexical scoping</em> which means that the function&#39;s scope inherits from where the function was defined (like in R). You can refer to variables  outside the scope in the parent.</li><li>Constants can be defined by <code>const</code> this does not allow changing the value  after; this really helps the compiler.</li><li>Each module intorduces a new global scope that is a separate world form other modules (oh boy this is where we can finally resolve the problem of too many conflicting names in R). <code>using</code> and <code>import</code> allow transportation of objects between those scopes. You can copy but you cannot insert and modify between  modules.</li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><ul><li>Function composition and piping!<ul><li>Composition operator (<code>\circ</code>) can combine two functions together</li><li>Piping is using the pipe (<code>|&gt;</code>) operator </li></ul></li><li>Dot syntax for vectorizing is very interesting.  <ul><li>Vectorizing is not required for performance, but they&#39;re still prettier</li><li>Any julia function can be applied by adding a <code>.</code> after like <code>.sin(V)</code>, or before the operator in the case of binary operators like <code>.+</code><ul><li>Amazing yet again!</li><li>This is just syntactic sugar for the <code>broadcast</code> function modifier</li><li>Nested brodcasts are joined together in a syntactic loop.</li><li>You can pre-allocate using the dotted assignment <code>.=</code></li><li>To avoid having too many dots then you can use the <code>@.</code> macro to add  dots to every singe funciton call in that line.</li></ul></li></ul></li><li>Anonymous functions use arrow like in JS: <code>(x) -&gt; x + 2</code></li></ul><h2 id="Control-Flow"><a class="docs-heading-anchor" href="#Control-Flow">Control Flow</a><a id="Control-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Flow" title="Permalink"></a></h2><h3 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h3><ul><li>Expressions using <code>begin</code> and <code>end</code> - no brackets so need this, you can also  separate into lines and use parens <code>(x = 1; y = 2; x + y)</code></li></ul><h3 id="Conditionals"><a class="docs-heading-anchor" href="#Conditionals">Conditionals</a><a id="Conditionals-1"></a><a class="docs-heading-anchor-permalink" href="#Conditionals" title="Permalink"></a></h3><ul><li><code>if</code>, <code>elseif</code>, <code>else</code>, <code>end</code> - nothing else to add simple enough<ul><li>If blocks do not have their own variable scope (same as R)</li><li>They can also return a value like in R</li><li>They must return a boolean</li></ul></li><li>Ternary operator can be used <code>condition ? iftrue: iffalse</code></li><li><code>&amp;&amp;</code> and <code>||</code> short circuit the expression like in R, so you can use it  to define some backup values or substitute the ternary operator</li><li><code>&amp;</code> and <code>|</code> evaluate both arguments</li></ul><pre><code class="language-julia">function fact(n::Int)
  n &gt;= 0 || error(&quot;n must be non-negative&quot;)
  n == 0 &amp;&amp; return 1
  n * fact(n-1)
end</code></pre><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><ul><li><code>while</code> loops look pretty standard, <code>break</code> breaks out of while.</li><li><code>for</code> loops look pretty standard, execpt for:<ul><li>you can loop  over different vectors using <code>for i = 1:2, j = 3:4</code>, now  that is a really good alternative to <code>purrr::map2</code> and avoiding nested  for loops</li><li>you can loop over using a tuple using <code>zip</code>:  <code>for (j, k) in zip([1 2 3], [4 5 6 7])</code></li></ul></li><li><code>1:5</code> syntax can be used like in R for indices</li><li>You can use <code>\epsilon</code> or <code>in</code> </li></ul><h3 id="Exception-Handling"><a class="docs-heading-anchor" href="#Exception-Handling">Exception Handling</a><a id="Exception-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Exception-Handling" title="Permalink"></a></h3><ul><li>There are a bunch of built-in exceptions: <ul><li><a href="https://docs.julialang.org/en/v1/manual/control-flow/#Built-in-Exceptions">here</a></li></ul></li><li>You can define also: <code>struct MyCustomException &lt;: Exception</code></li><li>Throw exceptions using <code>throw(DomainError(x, &quot;argument is not part of domain&quot;))</code></li><li><code>showerror</code> method on that error type allows you to define how that error  will be displayed</li><li><code>stop()</code> in R would be <code>error</code> throwing an <code>ErrorException</code> </li><li><code>try</code> - <code>catch</code> - <code>end</code> is implemented like so:</li></ul><pre><code class="language-julia">try 
  sqrt(&quot;ten&quot;)
catch e # this e is the exception 
  println(&quot;Needs to be numeric not a string&quot;)
end </code></pre><ul><li>can do inline try catch using <code>try condition catch e; expression end</code></li><li><code>finally</code> can be added to ensure that things are finalized (close db or file  connections and whatnot).</li></ul><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="General-type-system"><a class="docs-heading-anchor" href="#General-type-system">General type system</a><a id="General-type-system-1"></a><a class="docs-heading-anchor-permalink" href="#General-type-system" title="Permalink"></a></h3><ul><li>Julia&#39;s type system is ultimately dynamic but gains compiler advantages from type annotations.</li><li>Type annotations serve 3 purposes:<ol><li>take advantage of Julia&#39;s powerful multiple-dispatch mechanism</li><li>improve human readability</li><li>catch programming errors</li></ol></li><li>Why can&#39;t you inherit from a concrete type?<ul><li>inherit behavior (methods) more important than inheriting structure<ul><li>but I mean why not both?</li></ul></li><li>there are some difficulties with inheriting structure (? - unanswered)</li></ul></li><li>Salient aspects:<ul><li>No divison between object and non-object values</li><li>No compile time type</li><li>Only values have types not variables</li></ul></li></ul><h3 id="Type-declarations"><a class="docs-heading-anchor" href="#Type-declarations">Type declarations</a><a id="Type-declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Type-declarations" title="Permalink"></a></h3><ul><li><code>::</code> operator: &quot;is an instance of&quot;</li><li><code>(1 + 2)::Int</code> is a type assertion </li><li><code>x::Int = 1</code> is a type restriction of that variable</li><li><code>function sinc(x)::Float64</code> is a type restriction on the result</li></ul><h3 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h3><ul><li>Cannot be instantiated</li><li><code>abstract type «name» end</code></li><li>Default supertype is <code>Any</code> - all objects are instances of</li><li>Bottom type is <code>Union{}</code> nothins is a <code>Union{}</code> and all are supertypes</li><li><code>&lt;:</code> is operator for &quot;is a subtype of&quot;</li></ul><h3 id="Primitive-types"><a class="docs-heading-anchor" href="#Primitive-types">Primitive types</a><a id="Primitive-types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-types" title="Permalink"></a></h3><ul><li>You can declare these as bits but why?</li><li><code>primitive type &lt;&lt;name&gt;&gt; &lt;: &lt;&lt;supertype&gt;&gt; &lt;&lt;bits&gt;&gt; end</code></li></ul><h3 id="Composite-Types"><a class="docs-heading-anchor" href="#Composite-Types">Composite Types</a><a id="Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Types" title="Permalink"></a></h3><ul><li>composed of primitive types, called records or   structs or objects</li><li>Julia composite types cannot have methods in them, the methods are outside</li><li>By default two constructors area created which is just a  function with the elements of the struct as arguments, and one that takes <code>Any</code> type and attempts to do the conversion.</li><li>Structs are immutable (like pretty much anything in R except environments)  primarily for performance and secondarily for readability. They can be  made mutable using a <code>mutable struct</code> keyword though.</li><li>How do you decide whether a type can be immutable or not? Ask yourself if  two objects that have exactly the same fields are identical. If they are, it&#39;s usually an indicator that you want an immutable type.</li><li>All these declared types are of type <code>DataType</code></li></ul><h3 id="Type-Unions"><a class="docs-heading-anchor" href="#Type-Unions">Type Unions</a><a id="Type-Unions-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Unions" title="Permalink"></a></h3><ul><li>You moosh together two types and anything inherits from that like so: <code>IntOrString = Union{Int, AbstractString}</code></li><li><code>Union{T, Nothing}</code> is essentially a nullable type because it can be the special value <code>nothing</code>.</li></ul><h3 id="Parametric-types"><a class="docs-heading-anchor" href="#Parametric-types">Parametric types</a><a id="Parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-types" title="Permalink"></a></h3><ul><li>You can declare a parametric type like so:</li></ul><pre><code class="language-julia">struct Point{T}
  x::T
  y::T
end</code></pre><ul><li><code>Point</code> is also a type containing any of its parameterized equivalents as   subtypes.</li><li><code>Point{Float64}</code> is not a subtype of <code>Point{Real}</code>, so in order to define a  method that allows dispatching on both, use this form: </li></ul><pre><code class="language-julia">function norm(p::Point{&lt;:Real}) end </code></pre><ul><li><code>Point{&lt;:Real}</code> is really just a Point that is a <code>UnionAll</code> of all the  subtypes of <code>Real</code>, which explains how it works. You can also do  <code>Point{&gt;:Int}</code> to get all the supertypes of <code>Int</code>. </li><li>If you use the constructor in a way, it already defins the parameteric types, i.e. calling <code>Point(1.0, 2.0)</code> will generate a <code>Point{Float64}</code> automatically.</li><li>You can declare types as subtypes of parametric abstract types just like  any other type.</li></ul><h3 id="Tuple-Types"><a class="docs-heading-anchor" href="#Tuple-Types">Tuple Types</a><a id="Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-Types" title="Permalink"></a></h3><ul><li>Function arguments are tuples, which are really like immutable structs that  are parameterized by the type of each arugment, but some differences:<ol><li>Tuple types can have any number of parameters </li><li>Typle types are covariant, so <code>Tuple(Int)</code> is a subtype of <code>Tuple(Any)</code>.</li><li>Types do not have field names and are accessed by index.</li></ol></li><li><code>(1, &quot;foo&quot;, 2.5)</code> is a tuple</li><li>Tuples may have <code>Vararg{T, N}</code> which can match 0 to N arguments (Inf if <code>N</code> is omitted. There is a convenience <code>NTuple{N,T}</code> to represent a Tuple that has N elements of type T.</li></ul><h3 id="Named-Tuple-types"><a class="docs-heading-anchor" href="#Named-Tuple-types">Named Tuple types</a><a id="Named-Tuple-types-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Tuple-types" title="Permalink"></a></h3><ul><li>Is this the named list in R?</li><li>It has a tuple of symbols and a tuple of field types: `NamedTuple{(:a, :b), Tuple{Int64, String}}</li><li>You can use <code>@NamedTuple</code> to provide a more convenient struct-like syntax:</li></ul><pre><code class="language-julia">@NamedTuple begin 
  a::Int
  b::String 
end</code></pre><h3 id="UnionAll-Types"><a class="docs-heading-anchor" href="#UnionAll-Types">UnionAll Types</a><a id="UnionAll-Types-1"></a><a class="docs-heading-anchor-permalink" href="#UnionAll-Types" title="Permalink"></a></h3><ul><li><code>Array{&lt;:Integer}</code> is effectively <code>Array{T} where T&lt;:Integer</code>.</li><li>You can short form a type definition using: <code>Vector{T} = Array{T, 1}</code></li></ul><h3 id="Singleton-Types"><a class="docs-heading-anchor" href="#Singleton-Types">Singleton Types</a><a id="Singleton-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Singleton-Types" title="Permalink"></a></h3><ul><li>Immutable composite types with no fields: <code>struct NoFields end</code></li></ul><h3 id="Operations-on-Types"><a class="docs-heading-anchor" href="#Operations-on-Types">Operations on Types</a><a id="Operations-on-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Types" title="Permalink"></a></h3><ul><li><code>isa(x, y)</code> or <code>x &lt;: y</code> checks for subtypes</li><li><code>typeof()</code> returns the type of its argument</li><li><code>supertype()</code> returns the supertype of its argument</li></ul><h3 id="Custom-pretty-printing"><a class="docs-heading-anchor" href="#Custom-pretty-printing">Custom pretty-printing</a><a id="Custom-pretty-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-pretty-printing" title="Permalink"></a></h3><ul><li>Overload the <code>show</code> function: <code>Base.show(io::IO, z::Polar)</code></li><li>You can also change the output based on the MIME type: <code>Base.show(io::IO, ::MIME&quot;text/plain&quot;, z::Polar{T})</code></li></ul><h3 id="Value-types"><a class="docs-heading-anchor" href="#Value-types">Value types</a><a id="Value-types-1"></a><a class="docs-heading-anchor-permalink" href="#Value-types" title="Permalink"></a></h3><ul><li>You can dispatch on the actual value of a type using the <code>Val</code> keyword, but this is likely to be not idiomatic.</li></ul><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><blockquote><p>To facilitate using many different implementations of the same concept  smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of  argument types and counts. </p></blockquote><ul><li>A &quot;function&quot; is <ul><li>an object that maps a tuple of argyuments to a return value or throws  an exception if no appropriate value can be returned.</li><li>a conceptual operation that may be abstract</li></ul></li><li>A &quot;method&quot; is <ul><li>a specific concrete implementation or behavior of a fucntion.</li><li>a function defined is usually just one method</li></ul></li><li>Even if the concrete implementation is quite different, well designed dispatch will appear very coherent from the outside.</li><li>Multiple dispatch (like R&#39;s S4 but more deliberately made lol)<ul><li>Most specific (lower on the type tree) will be used.</li></ul></li><li>Ambiguities in selecting most specific type raise an error.</li><li>Just define a function but with type annotations and voila it&#39;s a method of  that function (already that&#39;s less typing than R)</li><li>All conversion in Julia is explicit (also different from R)</li><li>Use <code>methods(f)</code> to figure out the methods attached to the generic</li><li>No type means the <code>Any</code> apex type.</li></ul><h3 id="Parametric-Methods"><a class="docs-heading-anchor" href="#Parametric-Methods">Parametric Methods</a><a id="Parametric-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Methods" title="Permalink"></a></h3><ul><li>you can also define methods like so: <code>same_type(x::T, y::T) where {T}</code> which  applies whenever both <code>x</code> and <code>y</code> are of the same type.</li><li>You can also constrain those parameters by doing <code>where {T&lt;:Real}</code></li></ul><h3 id="Redefining-methods"><a class="docs-heading-anchor" href="#Redefining-methods">Redefining methods</a><a id="Redefining-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Redefining-methods" title="Permalink"></a></h3><ul><li>You cannot immediately use new method definitions as soon as you defined them usually in the same expression; use <code>Base.invokelatest(f)</code> to get around this.</li></ul><h3 id="Design-patterns"><a class="docs-heading-anchor" href="#Design-patterns">Design patterns</a><a id="Design-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Design-patterns" title="Permalink"></a></h3><ul><li><strong>Extracting the type parameter from a super-type</strong> </li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../ecosystem/">Ecosystem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 2 April 2021 15:53">Friday 2 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
