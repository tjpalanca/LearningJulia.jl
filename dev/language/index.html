<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Language · LearningJulia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LearningJulia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">General</span><ul><li class="is-active"><a class="tocitem" href>Language</a><ul class="internal"><li><a class="tocitem" href="#General-observations"><span>General observations</span></a></li><li class="toplevel"><a class="tocitem" href="#Reading-through-the-Julia-Language-Manual"><span>Reading through the Julia Language Manual</span></a></li><li><a class="tocitem" href="#Variable-Scope"><span>Variable Scope</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Control-Flow"><span>Control Flow</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Conversion-and-Promotion"><span>Conversion and Promotion</span></a></li><li><a class="tocitem" href="#Interfaces"><span>Interfaces</span></a></li><li><a class="tocitem" href="#Modules"><span>Modules</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../ecosystem/">Ecosystem</a></li><li><a class="tocitem" href="../dev_env/">Development Environment</a></li><li><a class="tocitem" href="../documentation/">Documentation</a></li></ul></li><li><span class="tocitem">Software Development</span><ul><li><a class="tocitem" href="../databases/">Databases</a></li><li><a class="tocitem" href="../orm/">Object-Relational Mapping</a></li><li><a class="tocitem" href="../web/">Web Development</a></li></ul></li><li><span class="tocitem">Data Science</span><ul><li><a class="tocitem" href="../dataframes/">Data Frames</a></li><li><a class="tocitem" href="../computation/">Computation</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li></ul></li><li><span class="tocitem">Interoperability</span><ul><li><a class="tocitem" href="../python/">Python</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../smart_home/">Smart Home</a></li><li><a class="tocitem" href="../blogging/">Blogging</a></li><li><a class="tocitem" href="../generative/">Generative Art</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">General</a></li><li class="is-active"><a href>Language</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Language</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tjpalanca/LearningJulia.jl/blob/master/docs/src/language.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-Language"><a class="docs-heading-anchor" href="#Julia-Language">Julia Language</a><a id="Julia-Language-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Language" title="Permalink"></a></h1><ul><li><a href="#Julia-Language">Julia Language</a></li><ul><li><a href="#General-observations">General observations</a></li></ul><li><a href="#Reading-through-the-Julia-Language-Manual">Reading through the Julia Language Manual</a></li><ul><li><a href="#Variable-Scope">Variable Scope</a></li><li><a href="#Functions">Functions</a></li><li><a href="#Control-Flow">Control Flow</a></li><li><a href="#Types">Types</a></li><li><a href="#Methods">Methods</a></li><li><a href="#Constructors">Constructors</a></li><li><a href="#Conversion-and-Promotion">Conversion and Promotion</a></li><li><a href="#Interfaces">Interfaces</a></li><li><a href="#Modules">Modules</a></li><li><a href="#Documentation">Documentation</a></li></ul></ul><h2 id="General-observations"><a class="docs-heading-anchor" href="#General-observations">General observations</a><a id="General-observations-1"></a><a class="docs-heading-anchor-permalink" href="#General-observations" title="Permalink"></a></h2><ul><li>I love the named slurping and splatting, an improvement of the R syntax</li><li>It looks like math! Very little cognitive load on translating some work.</li><li>However, the whole multiple dispatch thing, when I watch videos looks amazing, but when I try to implement makes my brain hurt. I suffer from the curse of seeing OOP in Python and R6 in R. S3 is quite similar but is so much  simpler because it&#39;s single dispatch.</li><li>Symbols and strings are separate - amaze! Metaprogramming has been something  that is quite easy in R and I suspect quite easy in Julia too with the macros.</li><li>Do-block syntax - interesting, the function is first and then the iterable in  Julia&#39;s <code>map()</code> as opposed to R&#39;s <code>purrr::map()</code>.</li><li>There&#39;s a lot of reference to language design here and I feel like I&#39;m also learning about it as I read through how to actually use Julia.</li></ul><h1 id="Reading-through-the-Julia-Language-Manual"><a class="docs-heading-anchor" href="#Reading-through-the-Julia-Language-Manual">Reading through the Julia Language Manual</a><a id="Reading-through-the-Julia-Language-Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-through-the-Julia-Language-Manual" title="Permalink"></a></h1><h2 id="Variable-Scope"><a class="docs-heading-anchor" href="#Variable-Scope">Variable Scope</a><a id="Variable-Scope-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Scope" title="Permalink"></a></h2><ul><li>Global and local scope</li><li><code>if</code> and <code>begin/end</code> blocks do not introduce new scopes</li><li>Julia uses <em>lexical scoping</em> which means that the function&#39;s scope inherits from where the function was defined (like in R). You can refer to variables  outside the scope in the parent.</li><li>Constants can be defined by <code>const</code> this does not allow changing the value  after; this really helps the compiler.</li><li>Each module intorduces a new global scope that is a separate world form other modules (oh boy this is where we can finally resolve the problem of too many conflicting names in R). <code>using</code> and <code>import</code> allow transportation of objects between those scopes. You can copy but you cannot insert and modify between  modules.</li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><ul><li>Function composition and piping!<ul><li>Composition operator (<code>\circ</code>) can combine two functions together</li><li>Piping is using the pipe (<code>|&gt;</code>) operator </li></ul></li><li>Dot syntax for vectorizing is very interesting.  <ul><li>Vectorizing is not required for performance, but they&#39;re still prettier</li><li>Any julia function can be applied by adding a <code>.</code> after like <code>.sin(V)</code>, or before the operator in the case of binary operators like <code>.+</code><ul><li>Amazing yet again!</li><li>This is just syntactic sugar for the <code>broadcast</code> function modifier</li><li>Nested brodcasts are joined together in a syntactic loop.</li><li>You can pre-allocate using the dotted assignment <code>.=</code></li><li>To avoid having too many dots then you can use the <code>@.</code> macro to add  dots to every singe funciton call in that line.</li></ul></li></ul></li><li>Anonymous functions use arrow like in JS: <code>(x) -&gt; x + 2</code></li></ul><h2 id="Control-Flow"><a class="docs-heading-anchor" href="#Control-Flow">Control Flow</a><a id="Control-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Flow" title="Permalink"></a></h2><h3 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h3><ul><li>Expressions using <code>begin</code> and <code>end</code> - no brackets so need this, you can also  separate into lines and use parens <code>(x = 1; y = 2; x + y)</code></li></ul><h3 id="Conditionals"><a class="docs-heading-anchor" href="#Conditionals">Conditionals</a><a id="Conditionals-1"></a><a class="docs-heading-anchor-permalink" href="#Conditionals" title="Permalink"></a></h3><ul><li><code>if</code>, <code>elseif</code>, <code>else</code>, <code>end</code> - nothing else to add simple enough<ul><li>If blocks do not have their own variable scope (same as R)</li><li>They can also return a value like in R</li><li>They must return a boolean</li></ul></li><li>Ternary operator can be used <code>condition ? iftrue: iffalse</code></li><li><code>&amp;&amp;</code> and <code>||</code> short circuit the expression like in R, so you can use it  to define some backup values or substitute the ternary operator</li><li><code>&amp;</code> and <code>|</code> evaluate both arguments</li></ul><pre><code class="language-julia">function fact(n::Int)
  n &gt;= 0 || error(&quot;n must be non-negative&quot;)
  n == 0 &amp;&amp; return 1
  n * fact(n-1)
end</code></pre><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><ul><li><code>while</code> loops look pretty standard, <code>break</code> breaks out of while.</li><li><code>for</code> loops look pretty standard, execpt for:<ul><li>you can loop  over different vectors using <code>for i = 1:2, j = 3:4</code>, now  that is a really good alternative to <code>purrr::map2</code> and avoiding nested  for loops</li><li>you can loop over using a tuple using <code>zip</code>:  <code>for (j, k) in zip([1 2 3], [4 5 6 7])</code></li></ul></li><li><code>1:5</code> syntax can be used like in R for indices</li><li>You can use <code>\epsilon</code> or <code>in</code> </li></ul><h3 id="Exception-Handling"><a class="docs-heading-anchor" href="#Exception-Handling">Exception Handling</a><a id="Exception-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Exception-Handling" title="Permalink"></a></h3><ul><li>There are a bunch of built-in exceptions: <ul><li><a href="https://docs.julialang.org/en/v1/manual/control-flow/#Built-in-Exceptions">here</a></li></ul></li><li>You can define also: <code>struct MyCustomException &lt;: Exception</code></li><li>Throw exceptions using <code>throw(DomainError(x, &quot;argument is not part of domain&quot;))</code></li><li><code>showerror</code> method on that error type allows you to define how that error  will be displayed</li><li><code>stop()</code> in R would be <code>error</code> throwing an <code>ErrorException</code> </li><li><code>try</code> - <code>catch</code> - <code>end</code> is implemented like so:</li></ul><pre><code class="language-julia">try 
  sqrt(&quot;ten&quot;)
catch e # this e is the exception 
  println(&quot;Needs to be numeric not a string&quot;)
end </code></pre><ul><li>can do inline try catch using <code>try condition catch e; expression end</code></li><li><code>finally</code> can be added to ensure that things are finalized (close db or file  connections and whatnot).</li></ul><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="General-type-system"><a class="docs-heading-anchor" href="#General-type-system">General type system</a><a id="General-type-system-1"></a><a class="docs-heading-anchor-permalink" href="#General-type-system" title="Permalink"></a></h3><ul><li>Julia&#39;s type system is ultimately dynamic but gains compiler advantages from type annotations.</li><li>Type annotations serve 3 purposes:<ol><li>take advantage of Julia&#39;s powerful multiple-dispatch mechanism</li><li>improve human readability</li><li>catch programming errors</li></ol></li><li>Why can&#39;t you inherit from a concrete type?<ul><li>inherit behavior (methods) more important than inheriting structure<ul><li>but I mean why not both?</li></ul></li><li>there are some difficulties with inheriting structure (? - unanswered)</li></ul></li><li>Salient aspects:<ul><li>No divison between object and non-object values</li><li>No compile time type</li><li>Only values have types not variables</li></ul></li></ul><h3 id="Type-declarations"><a class="docs-heading-anchor" href="#Type-declarations">Type declarations</a><a id="Type-declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Type-declarations" title="Permalink"></a></h3><ul><li><code>::</code> operator: &quot;is an instance of&quot;</li><li><code>(1 + 2)::Int</code> is a type assertion </li><li><code>x::Int = 1</code> is a type restriction of that variable</li><li><code>function sinc(x)::Float64</code> is a type restriction on the result</li></ul><h3 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h3><ul><li>Cannot be instantiated</li><li><code>abstract type «name» end</code></li><li>Default supertype is <code>Any</code> - all objects are instances of</li><li>Bottom type is <code>Union{}</code> nothins is a <code>Union{}</code> and all are supertypes</li><li><code>&lt;:</code> is operator for &quot;is a subtype of&quot;</li></ul><h3 id="Primitive-types"><a class="docs-heading-anchor" href="#Primitive-types">Primitive types</a><a id="Primitive-types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-types" title="Permalink"></a></h3><ul><li>You can declare these as bits but why?</li><li><code>primitive type &lt;&lt;name&gt;&gt; &lt;: &lt;&lt;supertype&gt;&gt; &lt;&lt;bits&gt;&gt; end</code></li></ul><h3 id="Composite-Types"><a class="docs-heading-anchor" href="#Composite-Types">Composite Types</a><a id="Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Types" title="Permalink"></a></h3><ul><li>composed of primitive types, called records or   structs or objects</li><li>Julia composite types cannot have methods in them, the methods are outside</li><li>By default two constructors area created which is just a  function with the elements of the struct as arguments, and one that takes <code>Any</code> type and attempts to do the conversion.</li><li>Structs are immutable (like pretty much anything in R except environments)  primarily for performance and secondarily for readability. They can be  made mutable using a <code>mutable struct</code> keyword though.</li><li>How do you decide whether a type can be immutable or not? Ask yourself if  two objects that have exactly the same fields are identical. If they are, it&#39;s usually an indicator that you want an immutable type.</li><li>All these declared types are of type <code>DataType</code></li></ul><h3 id="Type-Unions"><a class="docs-heading-anchor" href="#Type-Unions">Type Unions</a><a id="Type-Unions-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Unions" title="Permalink"></a></h3><ul><li>You moosh together two types and anything inherits from that like so: <code>IntOrString = Union{Int, AbstractString}</code></li><li><code>Union{T, Nothing}</code> is essentially a nullable type because it can be the special value <code>nothing</code>.</li></ul><h3 id="Parametric-types"><a class="docs-heading-anchor" href="#Parametric-types">Parametric types</a><a id="Parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-types" title="Permalink"></a></h3><ul><li>You can declare a parametric type like so:</li></ul><pre><code class="language-julia">struct Point{T}
  x::T
  y::T
end</code></pre><ul><li><code>Point</code> is also a type containing any of its parameterized equivalents as   subtypes.</li><li><code>Point{Float64}</code> is not a subtype of <code>Point{Real}</code>, so in order to define a  method that allows dispatching on both, use this form: </li></ul><pre><code class="language-julia">function norm(p::Point{&lt;:Real}) end </code></pre><ul><li><code>Point{&lt;:Real}</code> is really just a Point that is a <code>UnionAll</code> of all the  subtypes of <code>Real</code>, which explains how it works. You can also do  <code>Point{&gt;:Int}</code> to get all the supertypes of <code>Int</code>. </li><li>If you use the constructor in a way, it already defins the parameteric types, i.e. calling <code>Point(1.0, 2.0)</code> will generate a <code>Point{Float64}</code> automatically.</li><li>You can declare types as subtypes of parametric abstract types just like  any other type.</li></ul><h3 id="Tuple-Types"><a class="docs-heading-anchor" href="#Tuple-Types">Tuple Types</a><a id="Tuple-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-Types" title="Permalink"></a></h3><ul><li>Function arguments are tuples, which are really like immutable structs that  are parameterized by the type of each arugment, but some differences:<ol><li>Tuple types can have any number of parameters </li><li>Typle types are covariant, so <code>Tuple(Int)</code> is a subtype of <code>Tuple(Any)</code>.</li><li>Types do not have field names and are accessed by index.</li></ol></li><li><code>(1, &quot;foo&quot;, 2.5)</code> is a tuple</li><li>Tuples may have <code>Vararg{T, N}</code> which can match 0 to N arguments (Inf if <code>N</code> is omitted. There is a convenience <code>NTuple{N,T}</code> to represent a Tuple that has N elements of type T.</li></ul><h3 id="Named-Tuple-types"><a class="docs-heading-anchor" href="#Named-Tuple-types">Named Tuple types</a><a id="Named-Tuple-types-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Tuple-types" title="Permalink"></a></h3><ul><li>Is this the named list in R?</li><li>It has a tuple of symbols and a tuple of field types: `NamedTuple{(:a, :b), Tuple{Int64, String}}</li><li>You can use <code>@NamedTuple</code> to provide a more convenient struct-like syntax:</li></ul><pre><code class="language-julia">@NamedTuple begin 
  a::Int
  b::String 
end</code></pre><h3 id="UnionAll-Types"><a class="docs-heading-anchor" href="#UnionAll-Types">UnionAll Types</a><a id="UnionAll-Types-1"></a><a class="docs-heading-anchor-permalink" href="#UnionAll-Types" title="Permalink"></a></h3><ul><li><code>Array{&lt;:Integer}</code> is effectively <code>Array{T} where T&lt;:Integer</code>.</li><li>You can short form a type definition using: <code>Vector{T} = Array{T, 1}</code></li></ul><h3 id="Singleton-Types"><a class="docs-heading-anchor" href="#Singleton-Types">Singleton Types</a><a id="Singleton-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Singleton-Types" title="Permalink"></a></h3><ul><li>Immutable composite types with no fields: <code>struct NoFields end</code></li></ul><h3 id="Operations-on-Types"><a class="docs-heading-anchor" href="#Operations-on-Types">Operations on Types</a><a id="Operations-on-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-Types" title="Permalink"></a></h3><ul><li><code>isa(x, y)</code> or <code>x &lt;: y</code> checks for subtypes</li><li><code>typeof()</code> returns the type of its argument</li><li><code>supertype()</code> returns the supertype of its argument</li></ul><h3 id="Custom-pretty-printing"><a class="docs-heading-anchor" href="#Custom-pretty-printing">Custom pretty-printing</a><a id="Custom-pretty-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-pretty-printing" title="Permalink"></a></h3><ul><li>Overload the <code>show</code> function: <code>Base.show(io::IO, z::Polar)</code></li><li>You can also change the output based on the MIME type: <code>Base.show(io::IO, ::MIME&quot;text/plain&quot;, z::Polar{T})</code></li></ul><h3 id="Value-types"><a class="docs-heading-anchor" href="#Value-types">Value types</a><a id="Value-types-1"></a><a class="docs-heading-anchor-permalink" href="#Value-types" title="Permalink"></a></h3><ul><li>You can dispatch on the actual value of a type using the <code>Val</code> keyword, but this is likely to be not idiomatic.</li></ul><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><blockquote><p>To facilitate using many different implementations of the same concept  smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of  argument types and counts. </p></blockquote><ul><li>A &quot;function&quot; is <ul><li>an object that maps a tuple of argyuments to a return value or throws  an exception if no appropriate value can be returned.</li><li>a conceptual operation that may be abstract</li></ul></li><li>A &quot;method&quot; is <ul><li>a specific concrete implementation or behavior of a fucntion.</li><li>a function defined is usually just one method</li></ul></li><li>Even if the concrete implementation is quite different, well designed dispatch will appear very coherent from the outside.</li><li>Multiple dispatch (like R&#39;s S4 but more deliberately made lol)<ul><li>Most specific (lower on the type tree) will be used.</li></ul></li><li>Ambiguities in selecting most specific type raise an error.</li><li>Just define a function but with type annotations and voila it&#39;s a method of  that function (already that&#39;s less typing than R)</li><li>All conversion in Julia is explicit (also different from R)</li><li>Use <code>methods(f)</code> to figure out the methods attached to the generic</li><li>No type means the <code>Any</code> apex type.</li></ul><h3 id="Parametric-Methods"><a class="docs-heading-anchor" href="#Parametric-Methods">Parametric Methods</a><a id="Parametric-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Methods" title="Permalink"></a></h3><ul><li>you can also define methods like so: <code>same_type(x::T, y::T) where {T}</code> which  applies whenever both <code>x</code> and <code>y</code> are of the same type.</li><li>You can also constrain those parameters by doing <code>where {T&lt;:Real}</code></li></ul><h3 id="Redefining-methods"><a class="docs-heading-anchor" href="#Redefining-methods">Redefining methods</a><a id="Redefining-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Redefining-methods" title="Permalink"></a></h3><ul><li>You cannot immediately use new method definitions as soon as you defined them usually in the same expression; use <code>Base.invokelatest(f)</code> to get around this.</li></ul><h3 id="Design-patterns"><a class="docs-heading-anchor" href="#Design-patterns">Design patterns</a><a id="Design-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Design-patterns" title="Permalink"></a></h3><ul><li><strong>Extracting the type parameter from a super-type</strong> - You can use this  method to extract the type inside a parameterized type:</li></ul><pre><code class="language-julia">eltype(::Type{&lt;:AbstractArray{T}}) where {T} = T</code></pre><ul><li><strong>Building a similar type with a different type parameter</strong> - Use  <code>Base.similar</code> to create a mutable array with the given element type and  size. Use <code>Base.copyto!</code> in order to always create a copy.</li><li><strong>Iterated dispatch</strong> - You can dispatch first on the outer container then  continue down the dispatch tree (similar to single dispatch).</li><li><strong>Trait-based dispatch (Holy trait)</strong> - This stuff is really getting over my  head now haha. </li></ul><pre><code class="language-julia">map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)
# Base.IndexStyle(a, b) returns a trait that is going to return the best way 
# to index that particular set of parameters, and then you can just fall back 
# to the default implementation so you don&#39;t have to keep a tree.
map(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray)</code></pre><ul><li><strong>Output-type computation</strong> - <code>Base.promote_type</code> decides the output type  of the computation for the basic types. </li><li><strong>Separate convert and kernel logic</strong> - to reduce compile time is to isolate the conversion logic and the computation. </li><li><strong>Parametrically-constrained Varargs methods</strong> - use the same parameter in  the operated objected and the varargs so you can constrain the methods</li></ul><h3 id="Some-function-gotchas"><a class="docs-heading-anchor" href="#Some-function-gotchas">Some function gotchas</a><a id="Some-function-gotchas-1"></a><a class="docs-heading-anchor-permalink" href="#Some-function-gotchas" title="Permalink"></a></h3><ul><li>Note: keyword arguments do not operate on multiple dispatch</li><li>Note: default arguments are going to bne overridden if you specify a more  specific implementation afterwards.</li></ul><h3 id="Function-like-objects"><a class="docs-heading-anchor" href="#Function-like-objects">Function-like objects</a><a id="Function-like-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Function-like-objects" title="Permalink"></a></h3><ul><li>You can turn a type into a function that operates!</li><li>This is very similar to R where functions are first class objects.</li></ul><h3 id="Empty-generic-functions"><a class="docs-heading-anchor" href="#Empty-generic-functions">Empty generic functions</a><a id="Empty-generic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Empty-generic-functions" title="Permalink"></a></h3><ul><li>Use this to define a specific interface: <code>function emptyfunc end</code> </li></ul><h3 id="Method-design-and-the-avoidance-of-ambiguities"><a class="docs-heading-anchor" href="#Method-design-and-the-avoidance-of-ambiguities">Method design and the avoidance of ambiguities</a><a id="Method-design-and-the-avoidance-of-ambiguities-1"></a><a class="docs-heading-anchor-permalink" href="#Method-design-and-the-avoidance-of-ambiguities" title="Permalink"></a></h3><ul><li>Ambiguities can be hard to deal, here are some alternatives to just deifining a more specific method:<ul><li><code>Tuple</code> and <code>NTuple</code> arguments - in the empty case they are ambiguous as  to type so you can either define one on empty type or restrain your NTuple arguments to only where N &gt; 1</li><li>Orthogonalized design - nest the methods</li><li>Dispatch on one argument at a time (Single dispatch)</li><li>Don&#39;t define methods that dispatch on specific element types of  abstract containers, instead you should just define on a generic method and  construct a conceptual tree before specializing.</li><li>When recursing avoid relying on default arguments because you can cause  an infinite loop.</li></ul></li></ul><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><ul><li>It&#39;s just an automatically generated function that accompanies a struct.</li><li>&quot;Outer constructors&quot; - You can create new methods for it just like any other  function<ul><li>Use the same value for fields</li><li>Add default values</li></ul></li><li>&quot;Inner constructors&quot;<ul><li>needed for 2 use cases:<ol><li>enforcing invariants (validations)</li></ol><ul><li>ensures that no object (if immutable) will violate the invariant</li><li>you can&#39;t enforce with outer constructors because ultimately they  must call an inner constructor</li></ul><ol><li>allowing construction of self-referential objects</li></ol><ul><li>for recursive applications, you can call <code>new</code> without all the fields</li><li>you can create a self referential object like this</li></ul></li><li>declared inside the block of a type declaration</li><li>special access to a local function called <code>new</code> that is the default  constructor</li></ul></li></ul><pre><code class="language-julia">struct OrderedPair
  x::Real
  y::Real
  OrderedPair(x,y) = x &gt; y ? error(&quot;out of order&quot;) : new(x,y)
end</code></pre><ul><li>above object is now constraint to strictly decreasing</li><li>it does not enforce this if the struct is mutable, so only immutable  structs will have some sort of guarantee.</li><li>Best practices for constructors:<ul><li>as few inner constructors as possible</li><li>take all arguments explicitly and enforce essential error checking</li><li>provide ocnveniences as outer construtors</li></ul></li><li>Incomplete initialization</li><li>For recursion</li><li>Parametric constructors</li><li>Use the <code>promote</code> function heavily so that you can rationalize with only 1  type.</li></ul><h2 id="Conversion-and-Promotion"><a class="docs-heading-anchor" href="#Conversion-and-Promotion">Conversion and Promotion</a><a id="Conversion-and-Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-and-Promotion" title="Permalink"></a></h2><ul><li>Two approaches to promotion:<ol><li>Automatic promotion for built-ins (Perl, Python) </li></ol><ul><li>1 + 1.5 is automatically promoted to floating point  </li></ul><ol><li>No automatic promotion</li></ol><ul><li>quite inconvenient</li></ul></li><li>Julia falls into the no automatic promotion (#2) but implements some  polymorphic multiple dispatch as a special application. It can be edited by the user if they so choose and user-defined types can participate.</li></ul><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><ul><li>Just call the constructor on the object to be converted.</li><li><code>convert(::DataType, x)</code> function is the function on which we add conversion methods.</li><li>Julia does not aurtomatically convert between strings and numbers.</li><li>Conversion differs from construction in:<ol><li>Mutable collections</li><li>Where it&#39;s not really a conversion</li><li>Wrapper types - types that wrap other value.</li><li>Constructors that don&#39;t rteturn instances of their own type.</li></ol></li></ul><h3 id="Defining-new-conversions"><a class="docs-heading-anchor" href="#Defining-new-conversions">Defining new conversions</a><a id="Defining-new-conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-new-conversions" title="Permalink"></a></h3><ul><li>It&#39;s just a metter of defining a method for <code>convert</code></li><li>Only do this if implicit conversion is safe! Otherwise, rely on the  constructor functions being explicitly called.</li></ul><h3 id="Promotion"><a class="docs-heading-anchor" href="#Promotion">Promotion</a><a id="Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Promotion" title="Permalink"></a></h3><ul><li>Standardization of types prior to an operation.</li><li>Handled by the <code>promote()</code> method - <strong>but</strong> you don&#39;t define the rules on  <code>promote</code> but on the <code>promote_rule(::DataType, ::DataType)</code> which doesn&#39;t take the actual values but the datatypes. This is symmetric already so you don&#39;t need to define the flipped datatypes. This feeds into a function called <code>promote_type</code> that you can then use to actually determine what type the  value will end up being.</li><li>Aiming to be as lossless as possible.</li></ul><h2 id="Interfaces"><a class="docs-heading-anchor" href="#Interfaces">Interfaces</a><a id="Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces" title="Permalink"></a></h2><ul><li>Iteration interface<ul><li>defining an <code>iterate</code> method will allow you to use <ol><li><code>for</code> loops</li><li><code>in</code> operator</li><li><code>mean</code>, <code>std</code> etc</li></ol></li><li>defining <code>eltype</code> method will allow us to know more things like creating specialized iterable code that&#39;s faster</li><li>defining <code>length</code> allows us to preallocate and stuff like that</li><li>defining <code>firstindex</code> and <code>lastindex</code> allow us to specify the first and  last valid indices so we can use the <code>begin</code> and <code>end</code> indices</li></ul></li><li><code>AbstractArray</code> interface<ul><li><code>IndexStyle</code> is important to define for efficiency</li><li>This interface is extremely rich, simply defining: <code>struct SquaresVector &lt;: AbstractArray{Int, 1}</code> is enough to make it  iterable, indexable, and completely functional.</li></ul></li><li>Strided Arrays - a lot over my head</li><li>Customizing broadcasting - also over my head but I can see how that can be  super useful for building actual machine learning models.</li></ul><h2 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h2><ul><li>would be the whole package scope in an R package I suppose</li><li>key properties are: <ol><li>separate namespaces - avoids conflicts in function names</li><li>has <code>import</code> and <code>export</code> for defining what it needs and what it provides other modules (by default, there is no private namespace)</li><li>Modules can be precompiled for faster loading and contain code for  running initialization.</li></ol></li><li>module code is typically organized into files and then read in using  <code>include(&quot;file1.jl&quot;)</code>. </li><li>although related <code>include</code> is just adding the code in the file into wherever  it is and modules can be composed around or within that any which way.</li><li><code>parentmodule</code> finds the module that an object is contained</li><li>You can reserve variable names by declaring <code>global x</code> so that it cannot be  modified from outside the module.</li><li><code>using</code> loads all exports into the <code>Main</code> namespace, whereas <code>import</code> just brings the module name into scope, so you&#39;d need to quality everything in  there in order to use it. <ul><li><code>using Module: name1, name2</code> only brings specific names into global scope and the module name will not be in scope unless you also include it in  the names list. You can&#39;t add methods to a function without a namespace  (as it&#39;s &quot;using&quot;)</li><li><code>import Module: name1, name2</code> brings in the specific names and also  allows you to attach methods (usually done in other modules)</li></ul></li><li>You can use <code>as</code> to work around namespace conflicts like  <code>import CSV: read as rd</code> or <code>importBenchmarkTools as BT</code>. This is not  compatible with <code>using</code>/.</li><li>When modules export the same name:<ol><li>Use qualified name especially when they mean different things</li><li>use the keyword to reanme one or both with unqiue identifiers.</li><li>If they do share the same meaning then there is a unifier base package.</li></ol></li><li><code>Base</code> and <code>Core</code> are in the modules unless you define <code>baremodule</code></li><li><code>import .Module</code> imports a module defined in the current scope,  <code>import ..Module</code> imports a module defined in the parent module and so on. <code>..</code> is essentially a &quot;sibling&quot; module.</li></ul><h3 id="Module-initialization-and-pre-compilation"><a class="docs-heading-anchor" href="#Module-initialization-and-pre-compilation">Module initialization and pre-compilation</a><a id="Module-initialization-and-pre-compilation-1"></a><a class="docs-heading-anchor-permalink" href="#Module-initialization-and-pre-compilation" title="Permalink"></a></h3><ul><li>Whenever something is <code>import</code>-ed or <code>using</code>-ed the modulem is precompiled. Trigger manually using <code>Base.compilecache</code></li><li>Put <code>__precompile__(false)</code> in the module file at the top to prevent a module from being precompiled. </li><li>Don&#39;t precompile any external dependencies but rather define them at  runtime using the <code>__init__()</code> function, like external C libraries and global  constants that containe pointers returned by external library</li><li>Dictionaries can be safe to precompile if the key is generally standard types, not weird ones like <code>Function</code> or <code>DataType</code> or user-defined types without  a defined hash method.</li></ul><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><ul><li>Docstrings basically, interpreted as Markdown handled by <code>Markdown.jl</code>.</li><li>Standard for a docstring:</li></ul><pre><code class="language-julia">&quot;&quot;&quot;
    bar(x[, y]) # function signature with indent, optional with [], kwargs with ;
  
Imperative format of title ending with a period.

Additional details in a second paragraph that explains more implem details. Be 
concise and don&#39;t repeat yourself. 

# Arguments 

This part is only necessary if it&#39;s a complex function and those with kwargs.

See also: [`bar!`](@ref) # Hints to related functions 

# Examples

Written as doctests whenever possible

\```jldoctest 
julia&gt; code to run
output that matches the output exactly. Use [...] to truncate the output.
\```
&quot;&quot;&quot;</code></pre><ul><li><code>code</code> and <span>$LATEX$</span></li><li>92 characters wide max</li><li>Function implementation for custom types can be in an Implementation section. Intended for developers rather than users.</li><li>Long docstrings can be split off to an extended help header tahn can be  called explicitly by adding ??function rather than ?function</li><li>Ideally only the generic function needs to be documented, no need to  document the individual methods, unless the behavior differs explicitly.</li><li><code>@doc</code> macro allows you to insert expressions into the documentation. </li><li>Use <code>$($name)</code> to use string interpolation in docstrings</li><li>You can define a method on <code>Docs.getdoc</code> to be able to operate on that  type and access the data for it.</li><li>If you alias something, just document the original so that both can have  the documentation.</li><li>You can add a docstring to two things separated by a comma.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../ecosystem/">Ecosystem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 3 April 2021 15:26">Saturday 3 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
