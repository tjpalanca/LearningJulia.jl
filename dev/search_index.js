var documenterSearchIndex = {"docs":
[{"location":"bayesian/#Bayesian-Modeling","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"","category":"section"},{"location":"bayesian/","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"Source: bin/Bayesian.jl","category":"page"},{"location":"bayesian/","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"Bayesian modeling is an interest of mine ever since I read  [Towards a Principled Bayesian Workflow] by Michael Betancourt, so I'm keen to see if Julia has robust libraries for Probabilistic Programming like Stan, PyMC3, greta.","category":"page"},{"location":"bayesian/#Turing.jl","page":"Bayesian Modeling","title":"Turing.jl","text":"","category":"section"},{"location":"bayesian/","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"This looks the most complete so far","category":"page"},{"location":"smart_home/#Smart-Home","page":"Smart Home","title":"Smart Home","text":"","category":"section"},{"location":"smart_home/#SmartHomy.jl","page":"Smart Home","title":"SmartHomy.jl","text":"","category":"section"},{"location":"dev_env/#Development-Environment","page":"Development Environment","title":"Development Environment","text":"","category":"section"},{"location":"dev_env/#VS-Code-(code-server)-with-Julia-Extension","page":"Development Environment","title":"VS Code (code-server) with Julia Extension","text":"","category":"section"},{"location":"dev_env/","page":"Development Environment","title":"Development Environment","text":"I am coming from RStudio so I am very, very spoiled. \nI like VS Code so I decided to set up a cloud-based VS code instance using  the cdr/code-server docker image and layer R, Python, and Julia onto the  image. \nI am using Julia 1.6 as it mainly solves a lot of Time to First  Plot problems which I suspect will cause me issues. \nAfter watching some of the JuliaCon videos on YouTube, I was able to set up the Julia extension with inline results and some cool stuff like workspaces and environments. \nIt feels like RStudio! Although, the Language Server can  sometimes choke up for no apparent reason, and it takes a while for  autocomplete to kick in after loading a package using using.\nSome of the great features are on version control, particularly with the  Git Lens extensions. I can see how more software engineering-types will be  attracted to the Julia ecosystem compared to R which attracts domain  experts going in the opposite direction.\nI'm pretty sure I can find a VS code extension for anything I need; it's an  amazingly rich ecosystem!\nInline results are something else! Much better than a notebook interface and  better than also constantly looking at the console.","category":"page"},{"location":"dev_env/#OhMyREPL.jl","page":"Development Environment","title":"OhMyREPL.jl","text":"","category":"section"},{"location":"dev_env/","page":"Development Environment","title":"Development Environment","text":"That's cool! Packages can modify the REPL to a deep level. \n~/.julia/config/startup.jl is the equivalent of the .Rprofile file","category":"page"},{"location":"dev_env/#Pluto.jl","page":"Development Environment","title":"Pluto.jl","text":"","category":"section"},{"location":"dev_env/","page":"Development Environment","title":"Development Environment","text":"This is an interesting notebook interface that I want to take a look at.","category":"page"},{"location":"misc/#Miscellaneous-Packages","page":"Miscellaneous","title":"Miscellaneous Packages","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"ProgressLogging.jl - Added a progress logging interface","category":"page"},{"location":"web/#Web-Development","page":"Web Development","title":"Web Development","text":"","category":"section"},{"location":"web/#Basic-Packages","page":"Web Development","title":"Basic Packages","text":"","category":"section"},{"location":"web/#HTTP.jl","page":"Web Development","title":"HTTP.jl","text":"","category":"section"},{"location":"web/","page":"Web Development","title":"Web Development","text":"This seems to be one of the most fundamental web libraries in Julia.","category":"page"},{"location":"web/#WebIO.jl-ecosystem","page":"Web Development","title":"WebIO.jl ecosystem","text":"","category":"section"},{"location":"web/#Mux.jl","page":"Web Development","title":"Mux.jl","text":"","category":"section"},{"location":"web/#Genie.jl-ecosystem","page":"Web Development","title":"Genie.jl ecosystem","text":"","category":"section"},{"location":"web/#Dance.jl","page":"Web Development","title":"Dance.jl","text":"","category":"section"},{"location":"web/#JSServe.jl","page":"Web Development","title":"JSServe.jl","text":"","category":"section"},{"location":"databases/#Databases","page":"Databases","title":"Databases","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"Source: scripts/Database.jl Using: LibPQ.jl, Octo.jl, Stipple.jl","category":"page"},{"location":"databases/","page":"Databases","title":"Databases","text":"My favorite database is PostgreSQL, so I decided to see how I can access this database.\nThere's a standard interface for connecting to databases, but  sadly that doesn't seem to be available for Postgres, instead I'm redirected to the libpq interface LibPQ.jl","category":"page"},{"location":"databases/#LibPQ.jl","page":"Databases","title":"LibPQ.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"Is there something more high level that I can use? ","category":"page"},{"location":"databases/#Reading","page":"Databases","title":"Reading","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"With this, I'm able to to make queries and execute them, it's quite low level but it works for my standard Postgres installation.\nI'm able to transpose this into a DataFrame. I don't quite understand the many different tabular structures yet (I'm used to the built-in dataframe  in R), but I can see how that works. See Data Frames.","category":"page"},{"location":"databases/#Writing","page":"Databases","title":"Writing","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"DDL Statements have to be written manually\nTransactions have to be written manually (but easily wrapped)\nYes I can insert stuff, but still need SQL knowledge","category":"page"},{"location":"databases/#ODBC.jl","page":"Databases","title":"ODBC.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"This is a more standard interface, but it's less feature rich. I'm skipping  this for now but this might be the way to get to lesser known DBs.","category":"page"},{"location":"databases/#Octo.jl","page":"Databases","title":"Octo.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"It's a SQL Query DSL in Julia. Amazing, is this going to be like the  {dbplyr} package in R? Making a decent data access layer is soooooo hard!\nOkay so now I have to actually use structs\nIt supports Postgres, and MySQL and SQLite too!\nOkay I was able to query the information schema using a basic query tool.  I'm really not sure why I have to define a struct\nReally these function documentations are a little over my head: for example: Schema.model( will surface CoreType where T or something which does not really give me information about what arguments to place). May just be  that we need to add more docstrings or something?\nSQL keywords in the DSL part need to be capitalized\nI was able to query a bit and get in tune with the DSL, seems ok as a web app backend ORM but not for data analysis.","category":"page"},{"location":"databases/#Query.jl","page":"Databases","title":"Query.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"The package currently provides working implementations for in-memory data sources, but will eventually be able to translate queries into e.g. SQL. There is a prototype implementation of such a \"query provider\" for SQLite in the package, but it is experimental at this point and only works for a very small subset of queries.","category":"page"},{"location":"databases/","page":"Databases","title":"Databases","text":"This one is super promising but isn't implemented yet.","category":"page"},{"location":"language/#Julia-Language","page":"Language","title":"Julia Language","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Pages = [\"language.md\"]\nDepth = 2","category":"page"},{"location":"language/#General-observations","page":"Language","title":"General observations","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"I love the named slurping and splatting, an improvement of the R syntax\nIt looks like math! Very little cognitive load on translating some work.\nHowever, the whole multiple dispatch thing, when I watch videos looks amazing, but when I try to implement makes my brain hurt. I suffer from the curse of seeing OOP in Python and R6 in R. S3 is quite similar but is so much  simpler because it's single dispatch.\nSymbols and strings are separate - amaze! Metaprogramming has been something  that is quite easy in R and I suspect quite easy in Julia too with the macros.\nDo-block syntax - interesting, the function is first and then the iterable in  Julia's map() as opposed to R's purrr::map().\nThere's a lot of reference to language design here and I feel like I'm also learning about it as I read through how to actually use Julia.","category":"page"},{"location":"language/#Reading-through-the-Julia-Language-Manual","page":"Language","title":"Reading through the Julia Language Manual","text":"","category":"section"},{"location":"language/#Variable-Scope","page":"Language","title":"Variable Scope","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Global and local scope\nif and begin/end blocks do not introduce new scopes\nJulia uses lexical scoping which means that the function's scope inherits from where the function was defined (like in R). You can refer to variables  outside the scope in the parent.\nConstants can be defined by const this does not allow changing the value  after; this really helps the compiler.\nEach module intorduces a new global scope that is a separate world form other modules (oh boy this is where we can finally resolve the problem of too many conflicting names in R). using and import allow transportation of objects between those scopes. You can copy but you cannot insert and modify between  modules.","category":"page"},{"location":"language/#Functions","page":"Language","title":"Functions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Function composition and piping!\nComposition operator (\\circ) can combine two functions together\nPiping is using the pipe (|>) operator \nDot syntax for vectorizing is very interesting.  \nVectorizing is not required for performance, but they're still prettier\nAny julia function can be applied by adding a . after like .sin(V), or before the operator in the case of binary operators like .+\nAmazing yet again!\nThis is just syntactic sugar for the broadcast function modifier\nNested brodcasts are joined together in a syntactic loop.\nYou can pre-allocate using the dotted assignment .=\nTo avoid having too many dots then you can use the @. macro to add  dots to every singe funciton call in that line.\nAnonymous functions use arrow like in JS: (x) -> x + 2","category":"page"},{"location":"language/#Control-Flow","page":"Language","title":"Control Flow","text":"","category":"section"},{"location":"language/#Expressions","page":"Language","title":"Expressions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Expressions using begin and end - no brackets so need this, you can also  separate into lines and use parens (x = 1; y = 2; x + y)","category":"page"},{"location":"language/#Conditionals","page":"Language","title":"Conditionals","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"if, elseif, else, end - nothing else to add simple enough\nIf blocks do not have their own variable scope (same as R)\nThey can also return a value like in R\nThey must return a boolean\nTernary operator can be used condition ? iftrue: iffalse\n&& and || short circuit the expression like in R, so you can use it  to define some backup values or substitute the ternary operator\n& and | evaluate both arguments","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"function fact(n::Int)\n  n >= 0 || error(\"n must be non-negative\")\n  n == 0 && return 1\n  n * fact(n-1)\nend","category":"page"},{"location":"language/#Iteration","page":"Language","title":"Iteration","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"while loops look pretty standard, break breaks out of while.\nfor loops look pretty standard, execpt for:\nyou can loop  over different vectors using for i = 1:2, j = 3:4, now  that is a really good alternative to purrr::map2 and avoiding nested  for loops\nyou can loop over using a tuple using zip:  for (j, k) in zip([1 2 3], [4 5 6 7])\n1:5 syntax can be used like in R for indices\nYou can use \\epsilon or in ","category":"page"},{"location":"language/#Exception-Handling","page":"Language","title":"Exception Handling","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"There are a bunch of built-in exceptions: \nhere\nYou can define also: struct MyCustomException <: Exception\nThrow exceptions using throw(DomainError(x, \"argument is not part of domain\"))\nshowerror method on that error type allows you to define how that error  will be displayed\nstop() in R would be error throwing an ErrorException \ntry - catch - end is implemented like so:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"try \n  sqrt(\"ten\")\ncatch e # this e is the exception \n  println(\"Needs to be numeric not a string\")\nend ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"can do inline try catch using try condition catch e; expression end\nfinally can be added to ensure that things are finalized (close db or file  connections and whatnot).","category":"page"},{"location":"language/#Types","page":"Language","title":"Types","text":"","category":"section"},{"location":"language/#General-type-system","page":"Language","title":"General type system","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Julia's type system is ultimately dynamic but gains compiler advantages from type annotations.\nType annotations serve 3 purposes:\ntake advantage of Julia's powerful multiple-dispatch mechanism\nimprove human readability\ncatch programming errors\nWhy can't you inherit from a concrete type?\ninherit behavior (methods) more important than inheriting structure\nbut I mean why not both?\nthere are some difficulties with inheriting structure (? - unanswered)\nSalient aspects:\nNo divison between object and non-object values\nNo compile time type\nOnly values have types not variables","category":"page"},{"location":"language/#Type-declarations","page":"Language","title":"Type declarations","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":":: operator: \"is an instance of\"\n(1 + 2)::Int is a type assertion \nx::Int = 1 is a type restriction of that variable\nfunction sinc(x)::Float64 is a type restriction on the result","category":"page"},{"location":"language/#Abstract-types","page":"Language","title":"Abstract types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Cannot be instantiated\nabstract type «name» end\nDefault supertype is Any - all objects are instances of\nBottom type is Union{} nothins is a Union{} and all are supertypes\n<: is operator for \"is a subtype of\"","category":"page"},{"location":"language/#Primitive-types","page":"Language","title":"Primitive types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can declare these as bits but why?\nprimitive type <<name>> <: <<supertype>> <<bits>> end","category":"page"},{"location":"language/#Composite-Types","page":"Language","title":"Composite Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"composed of primitive types, called records or   structs or objects\nJulia composite types cannot have methods in them, the methods are outside\nBy default two constructors area created which is just a  function with the elements of the struct as arguments, and one that takes Any type and attempts to do the conversion.\nStructs are immutable (like pretty much anything in R except environments)  primarily for performance and secondarily for readability. They can be  made mutable using a mutable struct keyword though.\nHow do you decide whether a type can be immutable or not? Ask yourself if  two objects that have exactly the same fields are identical. If they are, it's usually an indicator that you want an immutable type.\nAll these declared types are of type DataType","category":"page"},{"location":"language/#Type-Unions","page":"Language","title":"Type Unions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You moosh together two types and anything inherits from that like so: IntOrString = Union{Int, AbstractString}\nUnion{T, Nothing} is essentially a nullable type because it can be the special value nothing.","category":"page"},{"location":"language/#Parametric-types","page":"Language","title":"Parametric types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can declare a parametric type like so:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"struct Point{T}\n  x::T\n  y::T\nend","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Point is also a type containing any of its parameterized equivalents as   subtypes.\nPoint{Float64} is not a subtype of Point{Real}, so in order to define a  method that allows dispatching on both, use this form: ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"function norm(p::Point{<:Real}) end ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Point{<:Real} is really just a Point that is a UnionAll of all the  subtypes of Real, which explains how it works. You can also do  Point{>:Int} to get all the supertypes of Int. \nIf you use the constructor in a way, it already defins the parameteric types, i.e. calling Point(1.0, 2.0) will generate a Point{Float64} automatically.\nYou can declare types as subtypes of parametric abstract types just like  any other type.","category":"page"},{"location":"language/#Tuple-Types","page":"Language","title":"Tuple Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Function arguments are tuples, which are really like immutable structs that  are parameterized by the type of each arugment, but some differences:\nTuple types can have any number of parameters \nTyple types are covariant, so Tuple(Int) is a subtype of Tuple(Any).\nTypes do not have field names and are accessed by index.\n(1, \"foo\", 2.5) is a tuple\nTuples may have Vararg{T, N} which can match 0 to N arguments (Inf if N is omitted. There is a convenience NTuple{N,T} to represent a Tuple that has N elements of type T.","category":"page"},{"location":"language/#Named-Tuple-types","page":"Language","title":"Named Tuple types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Is this the named list in R?\nIt has a tuple of symbols and a tuple of field types: `NamedTuple{(:a, :b), Tuple{Int64, String}}\nYou can use @NamedTuple to provide a more convenient struct-like syntax:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"@NamedTuple begin \n  a::Int\n  b::String \nend","category":"page"},{"location":"language/#UnionAll-Types","page":"Language","title":"UnionAll Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Array{<:Integer} is effectively Array{T} where T<:Integer.\nYou can short form a type definition using: Vector{T} = Array{T, 1}","category":"page"},{"location":"language/#Singleton-Types","page":"Language","title":"Singleton Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Immutable composite types with no fields: struct NoFields end","category":"page"},{"location":"language/#Operations-on-Types","page":"Language","title":"Operations on Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"isa(x, y) or x <: y checks for subtypes\ntypeof() returns the type of its argument\nsupertype() returns the supertype of its argument","category":"page"},{"location":"language/#Custom-pretty-printing","page":"Language","title":"Custom pretty-printing","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Overload the show function: Base.show(io::IO, z::Polar)\nYou can also change the output based on the MIME type: Base.show(io::IO, ::MIME\"text/plain\", z::Polar{T})","category":"page"},{"location":"language/#Value-types","page":"Language","title":"Value types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can dispatch on the actual value of a type using the Val keyword, but this is likely to be not idiomatic.","category":"page"},{"location":"language/#Methods","page":"Language","title":"Methods","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"To facilitate using many different implementations of the same concept  smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of  argument types and counts. ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"A \"function\" is \nan object that maps a tuple of argyuments to a return value or throws  an exception if no appropriate value can be returned.\na conceptual operation that may be abstract\nA \"method\" is \na specific concrete implementation or behavior of a fucntion.\na function defined is usually just one method\nEven if the concrete implementation is quite different, well designed dispatch will appear very coherent from the outside.\nMultiple dispatch (like R's S4 but more deliberately made lol)\nMost specific (lower on the type tree) will be used.\nAmbiguities in selecting most specific type raise an error.\nJust define a function but with type annotations and voila it's a method of  that function (already that's less typing than R)\nAll conversion in Julia is explicit (also different from R)\nUse methods(f) to figure out the methods attached to the generic\nNo type means the Any apex type.","category":"page"},{"location":"language/#Parametric-Methods","page":"Language","title":"Parametric Methods","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"you can also define methods like so: same_type(x::T, y::T) where {T} which  applies whenever both x and y are of the same type.\nYou can also constrain those parameters by doing where {T<:Real}","category":"page"},{"location":"language/#Redefining-methods","page":"Language","title":"Redefining methods","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You cannot immediately use new method definitions as soon as you defined them usually in the same expression; use Base.invokelatest(f) to get around this.","category":"page"},{"location":"language/#Design-patterns","page":"Language","title":"Design patterns","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Extracting the type parameter from a super-type - You can use this  method to extract the type inside a parameterized type:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"eltype(::Type{<:AbstractArray{T}}) where {T} = T","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Building a similar type with a different type parameter - Use  Base.similar to create a mutable array with the given element type and  size. Use Base.copyto! in order to always create a copy.\nIterated dispatch - You can dispatch first on the outer container then  continue down the dispatch tree (similar to single dispatch).\nTrait-based dispatch (Holy trait) - This stuff is really getting over my  head now haha. ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\n# Base.IndexStyle(a, b) returns a trait that is going to return the best way \n# to index that particular set of parameters, and then you can just fall back \n# to the default implementation so you don't have to keep a tree.\nmap(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray)","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Output-type computation - Base.promote_type decides the output type  of the computation for the basic types. \nSeparate convert and kernel logic - to reduce compile time is to isolate the conversion logic and the computation. \nParametrically-constrained Varargs methods - use the same parameter in  the operated objected and the varargs so you can constrain the methods","category":"page"},{"location":"language/#Some-function-gotchas","page":"Language","title":"Some function gotchas","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Note: keyword arguments do not operate on multiple dispatch\nNote: default arguments are going to bne overridden if you specify a more  specific implementation afterwards.","category":"page"},{"location":"language/#Function-like-objects","page":"Language","title":"Function-like objects","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can turn a type into a function that operates!\nThis is very similar to R where functions are first class objects.","category":"page"},{"location":"language/#Empty-generic-functions","page":"Language","title":"Empty generic functions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Use this to define a specific interface: function emptyfunc end ","category":"page"},{"location":"language/#Method-design-and-the-avoidance-of-ambiguities","page":"Language","title":"Method design and the avoidance of ambiguities","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Ambiguities can be hard to deal, here are some alternatives to just deifining a more specific method:\nTuple and NTuple arguments - in the empty case they are ambiguous as  to type so you can either define one on empty type or restrain your NTuple arguments to only where N > 1\nOrthogonalized design - nest the methods\nDispatch on one argument at a time (Single dispatch)\nDon't define methods that dispatch on specific element types of  abstract containers, instead you should just define on a generic method and  construct a conceptual tree before specializing.\nWhen recursing avoid relying on default arguments because you can cause  an infinite loop.","category":"page"},{"location":"language/#Constructors","page":"Language","title":"Constructors","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"It's just an automatically generated function that accompanies a struct.\n\"Outer constructors\" - You can create new methods for it just like any other  function\nUse the same value for fields\nAdd default values\n\"Inner constructors\"\nneeded for 2 use cases:\nenforcing invariants (validations)\nensures that no object (if immutable) will violate the invariant\nyou can't enforce with outer constructors because ultimately they  must call an inner constructor\nallowing construction of self-referential objects\nfor recursive applications, you can call new without all the fields\nyou can create a self referential object like this\ndeclared inside the block of a type declaration\nspecial access to a local function called new that is the default  constructor","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"struct OrderedPair\n  x::Real\n  y::Real\n  OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\nend","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"above object is now constraint to strictly decreasing\nit does not enforce this if the struct is mutable, so only immutable  structs will have some sort of guarantee.\nBest practices for constructors:\nas few inner constructors as possible\ntake all arguments explicitly and enforce essential error checking\nprovide ocnveniences as outer construtors\nIncomplete initialization\nFor recursion\nParametric constructors\nUse the promote function heavily so that you can rationalize with only 1  type.","category":"page"},{"location":"language/#Conversion-and-Promotion","page":"Language","title":"Conversion and Promotion","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Two approaches to promotion:\nAutomatic promotion for built-ins (Perl, Python) \n1 + 1.5 is automatically promoted to floating point  \nNo automatic promotion\nquite inconvenient\nJulia falls into the no automatic promotion (#2) but implements some  polymorphic multiple dispatch as a special application. It can be edited by the user if they so choose and user-defined types can participate.","category":"page"},{"location":"language/#Conversion","page":"Language","title":"Conversion","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Just call the constructor on the object to be converted.\nconvert(::DataType, x) function is the function on which we add conversion methods.\nJulia does not aurtomatically convert between strings and numbers.\nConversion differs from construction in:\nMutable collections\nWhere it's not really a conversion\nWrapper types - types that wrap other value.\nConstructors that don't rteturn instances of their own type.","category":"page"},{"location":"language/#Defining-new-conversions","page":"Language","title":"Defining new conversions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"It's just a metter of defining a method for convert\nOnly do this if implicit conversion is safe! Otherwise, rely on the  constructor functions being explicitly called.","category":"page"},{"location":"language/#Promotion","page":"Language","title":"Promotion","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Standardization of types prior to an operation.\nHandled by the promote() method - but you don't define the rules on  promote but on the promote_rule(::DataType, ::DataType) which doesn't take the actual values but the datatypes. This is symmetric already so you don't need to define the flipped datatypes. This feeds into a function called promote_type that you can then use to actually determine what type the  value will end up being.\nAiming to be as lossless as possible.","category":"page"},{"location":"language/#Interfaces","page":"Language","title":"Interfaces","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Iteration interface\ndefining an iterate method will allow you to use \nfor loops\nin operator\nmean, std etc\ndefining eltype method will allow us to know more things like creating specialized iterable code that's faster\ndefining length allows us to preallocate and stuff like that\ndefining firstindex and lastindex allow us to specify the first and  last valid indices so we can use the begin and end indices\nAbstractArray interface\nIndexStyle is important to define for efficiency\nThis interface is extremely rich, simply defining: struct SquaresVector <: AbstractArray{Int, 1} is enough to make it  iterable, indexable, and completely functional.\nStrided Arrays - a lot over my head\nCustomizing broadcasting - also over my head but I can see how that can be  super useful for building actual machine learning models.","category":"page"},{"location":"language/#Modules","page":"Language","title":"Modules","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"would be the whole package scope in an R package I suppose\nkey properties are: \nseparate namespaces - avoids conflicts in function names\nhas import and export for defining what it needs and what it provides other modules (by default, there is no private namespace)\nModules can be precompiled for faster loading and contain code for  running initialization.\nmodule code is typically organized into files and then read in using  include(\"file1.jl\"). \nalthough related include is just adding the code in the file into wherever  it is and modules can be composed around or within that any which way.\nparentmodule finds the module that an object is contained\nYou can reserve variable names by declaring global x so that it cannot be  modified from outside the module.\nusing loads all exports into the Main namespace, whereas import just brings the module name into scope, so you'd need to quality everything in  there in order to use it. \nusing Module: name1, name2 only brings specific names into global scope and the module name will not be in scope unless you also include it in  the names list. You can't add methods to a function without a namespace  (as it's \"using\")\nimport Module: name1, name2 brings in the specific names and also  allows you to attach methods (usually done in other modules)\nYou can use as to work around namespace conflicts like  import CSV: read as rd or importBenchmarkTools as BT. This is not  compatible with using/.\nWhen modules export the same name:\nUse qualified name especially when they mean different things\nuse the keyword to reanme one or both with unqiue identifiers.\nIf they do share the same meaning then there is a unifier base package.\nBase and Core are in the modules unless you define baremodule\nimport .Module imports a module defined in the current scope,  import ..Module imports a module defined in the parent module and so on. .. is essentially a \"sibling\" module.","category":"page"},{"location":"language/#Module-initialization-and-pre-compilation","page":"Language","title":"Module initialization and pre-compilation","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Whenever something is import-ed or using-ed the modulem is precompiled. Trigger manually using Base.compilecache\nPut __precompile__(false) in the module file at the top to prevent a module from being precompiled. \nDon't precompile any external dependencies but rather define them at  runtime using the __init__() function, like external C libraries and global  constants that containe pointers returned by external library\nDictionaries can be safe to precompile if the key is generally standard types, not weird ones like Function or DataType or user-defined types without  a defined hash method.","category":"page"},{"location":"language/#Documentation","page":"Language","title":"Documentation","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Docstrings basically, interpreted as Markdown handled by Markdown.jl.\nStandard for a docstring:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"\"\"\"\n    bar(x[, y]) # function signature with indent, optional with [], kwargs with ;\n  \nImperative format of title ending with a period.\n\nAdditional details in a second paragraph that explains more implem details. Be \nconcise and don't repeat yourself. \n\n# Arguments \n\nThis part is only necessary if it's a complex function and those with kwargs.\n\nSee also: [`bar!`](@ref) # Hints to related functions \n\n# Examples\n\nWritten as doctests whenever possible\n\n\\```jldoctest \njulia> code to run\noutput that matches the output exactly. Use [...] to truncate the output.\n\\```\n\"\"\"","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"code and LATEX\n92 characters wide max\nFunction implementation for custom types can be in an Implementation section. Intended for developers rather than users.\nLong docstrings can be split off to an extended help header tahn can be  called explicitly by adding ??function rather than ?function\nIdeally only the generic function needs to be documented, no need to  document the individual methods, unless the behavior differs explicitly.\n@doc macro allows you to insert expressions into the documentation. \nUse $($name) to use string interpolation in docstrings\nYou can define a method on Docs.getdoc to be able to operate on that  type and access the data for it.\nIf you alias something, just document the original so that both can have  the documentation.\nYou can add a docstring to two things separated by a comma.","category":"page"},{"location":"language/#Metaprogamming","page":"Language","title":"Metaprogamming","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Now this is going to be exciting!\nAll this (including R) inherits from Lisp.\nExpressions have two parts (type Expr, Expr(:call, :+, 1, 1))\nhead: indicating the type of expression - exp.head\nargs: the contents of the expression - exp.args\nExpressions can be nested and manipulated\nSymbols are represented as :symbol\nSymbol(\"func\", 10) turns into func10 so you can manipulate the  symbol with strings.\nQuoting\ncreation of expression objects \n:(a + b * c + 1) turns the quote string into an expression \nInterpolation\nmanipulating the expression objects without Expr using $\nex = :($a + b) turns into :(1 + b) because a is evaluiated and  a = 1.\nYou can also do splatting interpolation through $(xs...).  :(f(1, $(args...))) turns into :(f(1, x, y, z))\nthe $ is kinda like !! in R and the splatted one is !!!\nYou can nest down levels of quoting through $$$....\nQuoteNode avoids interpolating the :$\nEvaluation\nYou can execute the expression using eval\nModule.eval evaluates inside the global scope of the Module\nYou can define functions that manipulate these expressions\nMacros\nincluding generated code in the final body of a program\nmaps a tuple of arguments to a returned expression which is compiled  directly instead of at runtime\nThink of the result of the macro being inlined into the code by the  compiler and then that being compiled.\nInspect the expressiong using macroexpand \nmacroexpand(Main, :(@sayhello \"Troy\")) - you need to include  the module in which the macro will be evaluated.\nMacros receive the __source__ and __module__ argumens which contain  the line number of the invocation and the information about the expansion  module (like existing bindings).\nMacros rename local variabels to avoid name clashes with the module scope. You can use esc(ex) to escape this and ignore hygiene.\nMacros are also functions and can therefore take advantage of multiple dispatch, but they dispatch based on types of the AST not the evaluated values of the expressions","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"macro sayhello()\n  return :( println(\"Hello there!\") )\nend","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Boilerplate code can be generated programmatically using eval on a  quote ... end with interpolation. You can use the eval/quote pattern using the @eval macro","category":"page"},{"location":"language/#Non-standard-string-literals","page":"Language","title":"Non-standard string literals","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can define string literals like r\"^\\s\" which is a regex or b\"...\"  which is a byte array literal.\nYou can also take advantage of this by defining a macros that is of the form  {...}_str which allows you to define a string literal {...}\"...\".","category":"page"},{"location":"language/#Generated-functions","page":"Language","title":"Generated functions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can define using @generated and the function should return a quoted expression. \nI don't get this at all haha\nThere's also optionally generated functions.\nI feel like this is something where if we do it there's something wrong.","category":"page"},{"location":"language/#Multi-dimensional-arrays","page":"Language","title":"Multi-dimensional arrays","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Arrays are first class but not really any special from any other object: AbstractArray\nThere's no imperative to vectorize anything, it will be fast either way.\nAll arguments to functions are pased by sharing (pointers).\nBy convention ending with ! will mean that it mutates its arguments.\nYou can concatenate by [1:2, 4:5]\n[1:2; 4:5]\nList comprehensions: A way to construct arrays (like set consturction in  mathematics) [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\nGenerator expressions: without the brackets, these won't be evaluated  until you iterate on them. \nIndexing is done via square brackets: A[I_1, I_2, ..., I_n]\n: takes all indices for that particular dimension.\nbegin and end are special words that take the begininning and end.  the bracket is the method of getindex method for that type.\nIndexed assignment allows you to modify in place. indexed assignment is the  method of setindex! for that type.\nSupported index types\nscalar index that is an integer or an N-tuple corresponding to the dims: page[[CartesianIndex(1,1)]]\nArray of scalar indices page[1:4, 1:4, 1]\nAn object that represents an array of scalar indices and can be converted using to_indices, such as : or arrays of booleans like a conditional: page[[true, true, false, false]]\nLinear indexing is also possible when only one index i is given. This is  done in column-major iteration order, like it was reshaped into a one dimensional vector.\nYou can omit indices if the trailing dimensions are just one-dimensional, you can also add extra indices if the trailing dimensions are also just  one dimensional.\nIteration\nUse a for a in A # do something; end loop\nUse a for a in eachindex(A) #do something to A[i]; end loop\na in this case will be integer for linear otherwise CartesianIndex.\nDot syntax for vectorized operations\nsin.(x)\nx .+ y","category":"page"},{"location":"language/#Missing-Values","page":"Language","title":"Missing Values","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Yet another R feature that I really miss in Python, let's see what the  implementation is!\nmissing in a math operation returns missing, but only because the core  operations have handled these cases.\nFunctions that don't propagate missing values can do so by using the  Missings.jl.passmissing() function.\nmissing == missing returns missing, so use ismissing(x) to test for  missings. But the isequal(missing, missing) and missing === missing will return true\nmissing is considered as greater than any other value so when sorted  missings will be at the end of the ascending order\ntrue | missing returns true\nmissing | true returns true \ncontrol flow does not allow for missing value, nor do short circuiting ops.\nskipmissing() skips missing values (like the na.rm = TRUE argument)","category":"page"},{"location":"language/#Networking-and-Streams","page":"Language","title":"Networking and Streams","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Streams expose a read and a write with the stream as the first argument.\nFiles have open returning an IOStream object that can be used. This can  then be close-ed to flush to disk.\nTCP sockets are embedded in the Sockets standard library.","category":"page"},{"location":"language/#Parallel-Computing","page":"Language","title":"Parallel Computing","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"This is exciting! Native support for parallel images.\nAsynchronous tasks (coroutines) \nCommunication via Channels \nwait and fetch syntax.\nTasks are operations that can be interrupted and resumed at any time, is  this pretty much like a future in R?\nSyntax\nt = @task expr to declare a task\nschedule(t) schedules it for execution\nwait(t) blocks until completion\n@async macro creates and schedules a task immediately\nChannel communication \nwaitable first-in first-out queue. \nProducers put!(::Channel) while consumers take!(::Channel)\nput! blocks if Channel si full, take! blocks if it's empty.\nfetch gets the value but doesn't remove the value.\nclosed channels can still be read from until it's empty.\nMultithreading\nSet the JULIA_NUM_THREADS environment variable or use the command line  argument --threads to set more than 1 thread.\nBe careful to avoid data races by acquiring a lock around any data that you  suspect will be part of a data race. You can also make primitive types atomic (thread-safe) bty wrapping it in Atomic like:  Threads.Atomic{Int}(0)\nUse the Threads.@threads macro for a for loop to execute it in parallel.\nDistributed computing\nRunning multiple Julia processes with separate memory spaces. \nFor this we have the Distributed standard library.\nPrimitives\nremote references - can be used from any process to refer to an  object stored on that process\nFuture - not rewritable.\nRemoteChannel - rewritable so good for multiple processes.\nremote call - request by one process to call a certain function on  another porcess\nreturns a Future immediately, that you can wait and fetch.\nSyntax\nremotecall(f, workerid, args..., kwargs...) creates a future.\nremotecall_fetch fetches the value immediately.\n@spawnat workerid expr does the same thing but for expressions\nyou can @spawnat :any to pick whichever or the owners of  whatever futures are already defined.\nConsiderations \nYour code must be available about the worker. Use @everywhere to  run a piece of code in all workers so that they all have the  same environment. You can also use the -L julia argument to load a file on startup.\nGlobal variables are transferred when they are in closures.\nMinimize data movement as much as possible.\nYou can run parallel for loops by using @distributed.\n@distributed (+) for i = 1:2000000 will combine the results with a specific reduction (+).\nif you are iterating on an array you need to use SharedArrays.\nUse pmap() if you want to run an expensive iteration on multiple  elements. Use @distributed if the calculation is rather tiny.\nSetting up a cluster\nlocal cluster -p\nremote cluster using --machine-file, definition is: [count*][user@]host[:port] [bind_addr[:port]]\naddprocs, rmprocs, workers - you can manage processes\nGPU Computing\nYou can run Julia code natively on GPUs using the JuliaGPU.org  packages.","category":"page"},{"location":"language/#Running-External-Programs","page":"Language","title":"Running External Programs","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Now this is going to be useful for the Singer spec to be used.\nshell, Perl, and Ruby commands are referenced with backticks.\nThis creates a Cmd object that can be connected to pipes, run, read,  and written to. It does not capture output by default.\nYou can open to read from or write to an external command.\nYou can parse the comand just like a string\nUse $ to interpolate string literals. \nYou can use pipeline to construct a pipeline\nYou can use & to run pipelines in parallel, and also put that in pipeline","category":"page"},{"location":"language/#Miscellaneous-items","page":"Language","title":"Miscellaneous items","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Use Sys. iswindows() isapple() isunix() islinux() isbsd()  isfreebsd() to maange operating system variation.","category":"page"},{"location":"language/#Performance-Tips","page":"Language","title":"Performance Tips","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Avoid global variables\nUse @time to profile and watch out for memory allocation\nMake containers contain as concrete a type as possible.\nType declarations are helpful in:\nField names of structs - it's also better to parameterize the types of  fields in the types themselves.\nAvoid fields with absctract containers.\nAnnotate values taken from untyped locations.\nMake Julia specialize on types as much as possible.\nIf you have a lot of branching if statements likely you will want to break  that up into method definitions.\nWrite type stable functions, or annotate function return types\nAvoid changing the type of a variable, or annotate variable types\nDon't abuse multiple dispatch by encoding values as types\nAccess arrays in column-major order (how it's stored in memory)\nPre-allocate outputs\nFuse vectorized functions\nUse views to modify in place (view or @views macro on the expression)\nCopying data is sometimes good if the original memory map has already been  jumbled up or shuffled\nSmall fixed size vectors, use StaticArrays.jl\nAvoid string interpolation for IO as it builds a string instead of copying directly onto the connection","category":"page"},{"location":"language/#Workflow-Tips","page":"Language","title":"Workflow Tips","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Put the code in a temporary module (\"Tmp.jl\") and then put the test code in  a test code in another module (\"Tst.jl\") so that you can keep include-ing them as you develop your code.\nUse Revise.jl: make sure to load Revise before loading any code, so that  any modules are going to be updated as they are loaded, but there are  limitations:\nChanges to type defintitions\nChanges to vars and funcs that have the same name.","category":"page"},{"location":"language/#Style-Guide","page":"Language","title":"Style Guide","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"4 indentation level \nUse functions as soon as possible instead of scripts\nAvoid writing overly specific types\nHandle excess argument diversity in the caller\nUse ! to demarcate non-pure functions.\nAvoid strange Type Unions\nAvoid very very elaborate container types\nAvoid creating primitive types\nProvide default implementations for abstract types\nFunction naming\nSmoosh words together (i.e. haskey) and don't abbreviate words\nUse underscores when there are different concepts, i.e. remotecall_fetch\nFunction arguments \nFunctions first so you can use do syntax\nI/O Stream\nobject being mutated\nType\nobject not being mutated\nkey\nvalue \nAll others\nVarargs\nKwargs\nAvoid errors rather than using try catch to catch them\nDon't parenthesize conditions (if a == b not if (a == b))\nDon't overuse splicing \nPrefer instances to types\nDon't use unnecessary static parameters\nDon't overuse macros. If you use eval in a macro it's likely because you're using it to replace a function\nDon't expose unsafe operations at the interface level\nDon't overload methods of base container types, define your own type based on a common abstract type\nAvoid type piracy if you aren't collborated with the package imported\nUse isa or <: to test types not ==\nUse the least disruptive numeric types so as not to change the type of the  input argument","category":"page"},{"location":"blogging/#Blogging-/-Publishing","page":"Blogging","title":"Blogging / Publishing","text":"","category":"section"},{"location":"blogging/#Franklin.jl","page":"Blogging","title":"Franklin.jl","text":"","category":"section"},{"location":"blogging/","page":"Blogging","title":"Blogging","text":"I really like the {distill} package in R, maybe I can contribute a Distill theme for Franklin!","category":"page"},{"location":"computation/#Computation","page":"Computation","title":"Computation","text":"","category":"section"},{"location":"computation/#Dagger.jl","page":"Computation","title":"Dagger.jl","text":"","category":"section"},{"location":"computation/#Distributed.jl-and-Ecosystem","page":"Computation","title":"Distributed.jl and Ecosystem","text":"","category":"section"},{"location":"generative/#Generative-Art","page":"Generative Art","title":"Generative Art","text":"","category":"section"},{"location":"generative/","page":"Generative Art","title":"Generative Art","text":"nb/generative.jl and src/generative.jl","category":"page"},{"location":"generative/","page":"Generative Art","title":"Generative Art","text":"Something that coincideded with my desire to learn Julia was my desire to create some generative art, so it would be awesome if I could marry the two and really do some creative coding in Julia.","category":"page"},{"location":"generative/#Luxor.jl-Javis.jl","page":"Generative Art","title":"Luxor.jl + Javis.jl","text":"","category":"section"},{"location":"generative/#Luxor.jl","page":"Generative Art","title":"Luxor.jl","text":"","category":"section"},{"location":"generative/","page":"Generative Art","title":"Generative Art","text":"These two pair together for static and animated charts. Seems very well  featured and the tutorials are great. I think for generative art this combo will serve us best whereas Compose.jl is really more about visualization. This tutorial is pretty amazing!\nThis seems more amenable to being Julian, i.e. using features such as  broadcasting \nLuxor is great, the tutorial material is pretty gold standard.\nShapes\nWrap more complicated geoms around functions with parameters","category":"page"},{"location":"generative/#Javis.jl","page":"Generative Art","title":"Javis.jl","text":"","category":"section"},{"location":"generative/","page":"Generative Art","title":"Generative Art","text":"Ran into a bit of a hiccup with one of the dependencies on my cloud instance  Gtk.jl which required a display, so I needed to install xvfb to clear that precompilation issue, and then add it to the docker entrypoint.\nDoesn't yet fully support Pluto.jl but some things can be hacked around.\nWe create Luxor.jl functions that construct objects, and then  Javis Objects essentially are rendered for each frame from  closures defined through those Luxor objects.","category":"page"},{"location":"generative/#Compose.jl","page":"Generative Art","title":"Compose.jl","text":"","category":"section"},{"location":"generative/","page":"Generative Art","title":"Generative Art","text":"Takes inspiration from R's {grid}\ncompose(a, b) returns a new tree rooted at a with b as child.\nThere is a Forms gallery a Properties gallery, and  a Transforms gallery that  are all pretty featured \nSeems pretty well featured for SVG Graphics but no direct path to animation.","category":"page"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Using: Documenter.jl","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"I'm interested to see how well we can document stuff, and I'm going to  mainly use the package documentation feature to document my findings during this exploration.\nSeems pretty good so far! I really like the freeformness of the documentation that we can link to docstrings and such. R's documentation system via  {roxygen2} is more restrictive and sometimes requires me to add a lot of  boilerplate. This one feels just right.\nOther packages have very scant package documentation. This is an opportunity to start contributing!","category":"page"},{"location":"packages/#Package-Ecosystem","page":"Packages","title":"Package Ecosystem","text":"","category":"section"},{"location":"packages/","page":"Packages","title":"Packages","text":"I'm spoiled by CRAN. It's a pain to submit and maintain but it does result  in such a good user experience.\nPkg is a great package manager with environments built in! What a relief  as python's venv, conda, etc was difficult to grok.\nI'm seeing that the Pkg registration process is quite liberal, so now I'm  struggling to find a way to easily gate the quality of packages and the  updated-ness of packages I want to use.","category":"page"},{"location":"packages/#Pkg.jl","page":"Packages","title":"Pkg.jl","text":"","category":"section"},{"location":"packages/","page":"Packages","title":"Packages","text":"Designed around environments (independent sets of packages).\nManifest file contains the exact versions of packages\nDependency hell is managed because packages can have different dependency versions and use whatever is current at the time.\nYou can modify a dependency by doing develop --local Example and then  go back to the standard version by doing free Example\nadd a package to bring it from the registry to the environment\nst provides the current package and versions\nadd <github-repo> or add <local-path> are also possible.\nup Example to update a package\ntest package runs test suites\nbuild runs the package build process\ngc to prune / garbage-collect packages\nactivate <dir> creates a package in the current directory\nprecompile runs the precompilation scripts\ninstantiate restores the package environment","category":"page"},{"location":"packages/#Creating-packages","page":"Packages","title":"Creating packages","text":"","category":"section"},{"location":"packages/","page":"Packages","title":"Packages","text":"generate creates a basic structure.\nadd package dependencies. You can then import them into your own modules.\ndeps/build.jl is the build script and then the results will be in  deps/build.log\ntest/runtests.jl will be run for tests. this uses the test/Project.toml environment for test-specific dependencies.\nPackage naming guidelines\nAvoid jargon\nAvoid using Julia or prefixing with Ju.\nEnd with .jl to indicate that it's a Julia package\nPluralized names for the functionality they provide: DataFrames.jl for the  DataFrame type, etc.\nErr on the side of clarity\nLess systematic name may suit a package that is one implementation only\nIf you wrap a library then name it after that library.\nAvoid naming it too closely to an existing package\nUse Registrator to  register packages. ","category":"page"},{"location":"packages/#Package-compatibility","page":"Packages","title":"Package compatibility","text":"","category":"section"},{"location":"packages/","page":"Packages","title":"Packages","text":"Add a [compat] section to the Project.toml to indicate compatibility with  specific version of packages and Julia.\nPre-0.1 versions are not compatible with each other.\nPost-0.1 but Pre-1.0 versions are considered compatible for patch versions \nCaret Specifies allow upgrade up to the next major version\nTilde specificers allow upgrade up to the next minor version\nEquality specifiers do not allow upgrades\nInequality specifiers allow unbounded inequality compatibility\nHyphen specifiers can be used to supply exact version ranges.","category":"page"},{"location":"packages/#Registries","page":"Packages","title":"Registries","text":"","category":"section"},{"location":"packages/","page":"Packages","title":"Packages","text":"You can registry add to add a new registry. This is just a github repo with the pointers to the right packages.\nYou can registry rm \nYou can registry up to update a registry.","category":"page"},{"location":"packages/#Artifacts","page":"Packages","title":"Artifacts","text":"","category":"section"},{"location":"packages/","page":"Packages","title":"Packages","text":"immutable filesystem storage for anything that is not Julia.\nArtifacts.toml file which specifies tarfiles from a URL. ","category":"page"},{"location":"packages/","page":"Packages","title":"Packages","text":"+++ [<artifact-name>] git-tree-sha = \"Tar.treehash(IOBuffer(inflategzip(filename)))\" # Git Tree Hash of the downloaded content","category":"page"},{"location":"packages/","page":"Packages","title":"Packages","text":"[[<artifact-name.download>]]   url = \"<url-of-artifact>   sha256 = \"SHA.bytes2hex(open(sha256, filename))\" # SHA of the download file +++","category":"page"},{"location":"packages/","page":"Packages","title":"Packages","text":"You can then refer to this folder with artifact\"<artifact_name>\"\nIt's possible for artifacts to have no download stanza because it would be  filled in by code later.\nArtifacts are better than using the package directory because:\nit makes package installation stateless\nyou can share artifacts between different package versions","category":"page"},{"location":"orm/#Object-Relational-Mapping","page":"Object-Relational Mapping","title":"Object-Relational Mapping","text":"","category":"section"},{"location":"orm/","page":"Object-Relational Mapping","title":"Object-Relational Mapping","text":"Using: Stipple.jl, Octo.jl","category":"page"},{"location":"dataframes/#Data-Frames","page":"Data Frames","title":"Data Frames","text":"","category":"section"},{"location":"dataframes/","page":"Data Frames","title":"Data Frames","text":"I'm mainly coming at this from a Data Science and Backend systems point of view, so data frames are going to be hugely important.","category":"page"},{"location":"python/#Python-interoperability","page":"Python","title":"Python interoperability","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"I want to be able ot manage environments and use packages in Python as binaries, not necessarily requiring such a deep integration.","category":"page"},{"location":"python/#Conda.jl","page":"Python","title":"Conda.jl","text":"","category":"section"},{"location":"#LearningJulia.jl","page":"Introduction","title":"LearningJulia.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is just a container for all the code I write while trying to  learn the Julia language.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"I'm just writing bullet points and notes as a stream-of-consciousness, so  this won't be particularly organized, but hopefully this will help other R  users coming to Julia on what to watch out for and how well it might map to similar workflows.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 1","category":"page"}]
}
