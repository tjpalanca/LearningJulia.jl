var documenterSearchIndex = {"docs":
[{"location":"bayesian/#Bayesian-Modeling","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"","category":"section"},{"location":"bayesian/","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"Source: bin/Bayesian.jl","category":"page"},{"location":"bayesian/","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"Bayesian modeling is an interest of mine ever since I read  [Towards a Principled Bayesian Workflow] by Michael Betancourt, so I'm keen to see if Julia has robust libraries for Probabilistic Programming like Stan, PyMC3, greta.","category":"page"},{"location":"bayesian/#Turing.jl","page":"Bayesian Modeling","title":"Turing.jl","text":"","category":"section"},{"location":"bayesian/","page":"Bayesian Modeling","title":"Bayesian Modeling","text":"This looks the most complete so far","category":"page"},{"location":"smart_home/#Smart-Home","page":"Smart Home","title":"Smart Home","text":"","category":"section"},{"location":"smart_home/#SmartHomy.jl","page":"Smart Home","title":"SmartHomy.jl","text":"","category":"section"},{"location":"dev_env/#Development-Environment","page":"Development Environment","title":"Development Environment","text":"","category":"section"},{"location":"dev_env/#VS-Code-(coder-server)-with-Julia-Extension","page":"Development Environment","title":"VS Code (coder-server) with Julia Extension","text":"","category":"section"},{"location":"dev_env/","page":"Development Environment","title":"Development Environment","text":"I am coming from RStudio so I am very, very spoiled. \nI like VS Code so I decided to set up a cloud-based VS code instance using  the cdr/code-server docker image and layer R, Python, and Julia onto the  image. \nI am using Julia 1.6 as it mainly solves a lot of Time to First  Plot problems which I suspect will cause me issues. \nAfter watching some of the JuliaCon videos on YouTube, I was able to set up the Julia extension with inline results and some cool stuff like workspaces and environments. \nIt feels like RStudio! Although, the Language Server can  sometimes choke up for no apparent reason, and it takes a while for  autocomplete to kick in after loading a package using using.\nSome of the great features are on version control, particularly with the  Git Lens extensions. I can see how more software engineering-types will be  attracted to the Julia ecosystem compared to R which attracts domain  experts going in the opposite direction.\nI'm pretty sure I can find a VS code extension for anything I need; it's an  amazingly rich ecosystem!\nInline results are something else! Much better than a notebook interface and  better than also constantly looking at the console.","category":"page"},{"location":"dev_env/#OhMyREPL.jl","page":"Development Environment","title":"OhMyREPL.jl","text":"","category":"section"},{"location":"dev_env/","page":"Development Environment","title":"Development Environment","text":"That's cool! Packages can modify the REPL to a deep level. \n~/.julia/config/startup.jl is the equivalent of the .Rprofile file","category":"page"},{"location":"dev_env/#Pluto.jl","page":"Development Environment","title":"Pluto.jl","text":"","category":"section"},{"location":"dev_env/","page":"Development Environment","title":"Development Environment","text":"This is an interesting notebook interface that I want to take a look at.\n","category":"page"},{"location":"ecosystem/#Package-Ecosystem","page":"Ecosystem","title":"Package Ecosystem","text":"","category":"section"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"I'm spoiled by CRAN. It's a pain to submit and maintain but it does result  in such a good user experience.\nPkg is a great package manager with environments built in! What a relief  as python's venv, conda, etc was difficult to grok.\nI'm seeing that the Pkg registration process is quite liberal, so now I'm  struggling to find a way to easily gate the quality of packages and the  updated-ness of packages I want to use.","category":"page"},{"location":"ecosystem/","page":"Ecosystem","title":"Ecosystem","text":"","category":"page"},{"location":"web/#Web-Development","page":"Web Development","title":"Web Development","text":"","category":"section"},{"location":"web/#Basic-Packages","page":"Web Development","title":"Basic Packages","text":"","category":"section"},{"location":"web/#HTTP.jl","page":"Web Development","title":"HTTP.jl","text":"","category":"section"},{"location":"web/","page":"Web Development","title":"Web Development","text":"This seems to be one of the most fundamental web libraries in Julia.","category":"page"},{"location":"web/#WebIO.jl-ecosystem","page":"Web Development","title":"WebIO.jl ecosystem","text":"","category":"section"},{"location":"web/#Mux.jl","page":"Web Development","title":"Mux.jl","text":"","category":"section"},{"location":"web/#Genie.jl-ecosystem","page":"Web Development","title":"Genie.jl ecosystem","text":"","category":"section"},{"location":"web/#Dance.jl","page":"Web Development","title":"Dance.jl","text":"","category":"section"},{"location":"web/#JSServe.jl","page":"Web Development","title":"JSServe.jl","text":"","category":"section"},{"location":"databases/#Databases","page":"Databases","title":"Databases","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"Source: scripts/Database.jl Using: LibPQ.jl, Octo.jl, Stipple.jl","category":"page"},{"location":"databases/","page":"Databases","title":"Databases","text":"My favorite database is PostgreSQL, so I decided to see how I can access this database.\nThere's a standard interface for connecting to databases, but  sadly that doesn't seem to be available for Postgres, instead I'm redirected to the libpq interface LibPQ.jl","category":"page"},{"location":"databases/#LibPQ.jl","page":"Databases","title":"LibPQ.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"Is there something more high level that I can use? ","category":"page"},{"location":"databases/#Reading","page":"Databases","title":"Reading","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"With this, I'm able to to make queries and execute them, it's quite low level but it works for my standard Postgres installation.\nI'm able to transpose this into a DataFrame. I don't quite understand the many different tabular structures yet (I'm used to the built-in dataframe  in R), but I can see how that works. See Data Frames.","category":"page"},{"location":"databases/#Writing","page":"Databases","title":"Writing","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"DDL Statements have to be written manually\nTransactions have to be written manually (but easily wrapped)\nYes I can insert stuff, but still need SQL knowledge","category":"page"},{"location":"databases/#ODBC.jl","page":"Databases","title":"ODBC.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"This is a more standard interface, but it's less feature rich. I'm skipping  this for now but this might be the way to get to lesser known DBs.","category":"page"},{"location":"databases/#Octo.jl","page":"Databases","title":"Octo.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"It's a SQL Query DSL in Julia. Amazing, is this going to be like the  {dbplyr} package in R? Making a decent data access layer is soooooo hard!\nOkay so now I have to actually use structs\nIt supports Postgres, and MySQL and SQLite too!\nOkay I was able to query the information schema using a basic query tool.  I'm really not sure why I have to define a struct\nReally these function documentations are a little over my head: for example: Schema.model( will surface CoreType where T or something which does not really give me information about what arguments to place). May just be  that we need to add more docstrings or something?\nSQL keywords in the DSL part need to be capitalized\nI was able to query a bit and get in tune with the DSL, seems ok as a web app backend ORM but not for data analysis.","category":"page"},{"location":"databases/#Query.jl","page":"Databases","title":"Query.jl","text":"","category":"section"},{"location":"databases/","page":"Databases","title":"Databases","text":"The package currently provides working implementations for in-memory data sources, but will eventually be able to translate queries into e.g. SQL. There is a prototype implementation of such a \"query provider\" for SQLite in the package, but it is experimental at this point and only works for a very small subset of queries.","category":"page"},{"location":"databases/","page":"Databases","title":"Databases","text":"This one is super promising but isn't implemented yet.","category":"page"},{"location":"language/#Julia-Language","page":"Language","title":"Julia Language","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Pages = [\"language.md\"]\nDepth = 2","category":"page"},{"location":"language/#General-observations","page":"Language","title":"General observations","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"I love the named slurping and splatting, an improvement of the R syntax\nIt looks like math! Very little cognitive load on translating some work.\nHowever, the whole multiple dispatch thing, when I watch videos looks amazing, but when I try to implement makes my brain hurt. I suffer from the curse of seeing OOP in Python and R6 in R. S3 is quite similar but is so much  simpler because it's single dispatch.\nSymbols and strings are separate - amaze! Metaprogramming has been something  that is quite easy in R and I suspect quite easy in Julia too with the macros.\nDo-block syntax - interesting, the function is first and then the iterable in  Julia's map() as opposed to R's purrr::map().\nThere's a lot of reference to language design here and I feel like I'm also learning about it as I read through how to actually use Julia.","category":"page"},{"location":"language/#Reading-through-the-Julia-Language-Manual","page":"Language","title":"Reading through the Julia Language Manual","text":"","category":"section"},{"location":"language/#Variable-Scope","page":"Language","title":"Variable Scope","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Global and local scope\nif and begin/end blocks do not introduce new scopes\nJulia uses lexical scoping which means that the function's scope inherits from where the function was defined (like in R). You can refer to variables  outside the scope in the parent.\nConstants can be defined by const this does not allow changing the value  after; this really helps the compiler.\nEach module intorduces a new global scope that is a separate world form other modules (oh boy this is where we can finally resolve the problem of too many conflicting names in R). using and import allow transportation of objects between those scopes. You can copy but you cannot insert and modify between  modules.","category":"page"},{"location":"language/#Functions","page":"Language","title":"Functions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Function composition and piping!\nComposition operator (\\circ) can combine two functions together\nPiping is using the pipe (|>) operator \nDot syntax for vectorizing is very interesting.  \nVectorizing is not required for performance, but they're still prettier\nAny julia function can be applied by adding a . after like .sin(V), or before the operator in the case of binary operators like .+\nAmazing yet again!\nThis is just syntactic sugar for the broadcast function modifier\nNested brodcasts are joined together in a syntactic loop.\nYou can pre-allocate using the dotted assignment .=\nTo avoid having too many dots then you can use the @. macro to add  dots to every singe funciton call in that line.\nAnonymous functions use arrow like in JS: (x) -> x + 2","category":"page"},{"location":"language/#Control-Flow","page":"Language","title":"Control Flow","text":"","category":"section"},{"location":"language/#Expressions","page":"Language","title":"Expressions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Expressions using begin and end - no brackets so need this, you can also  separate into lines and use parens (x = 1; y = 2; x + y)","category":"page"},{"location":"language/#Conditionals","page":"Language","title":"Conditionals","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"if, elseif, else, end - nothing else to add simple enough\nIf blocks do not have their own variable scope (same as R)\nThey can also return a value like in R\nThey must return a boolean\nTernary operator can be used condition ? iftrue: iffalse\n&& and || short circuit the expression like in R, so you can use it  to define some backup values or substitute the ternary operator\n& and | evaluate both arguments","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"function fact(n::Int)\n  n >= 0 || error(\"n must be non-negative\")\n  n == 0 && return 1\n  n * fact(n-1)\nend","category":"page"},{"location":"language/#Iteration","page":"Language","title":"Iteration","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"while loops look pretty standard, break breaks out of while.\nfor loops look pretty standard, execpt for:\nyou can loop  over different vectors using for i = 1:2, j = 3:4, now  that is a really good alternative to purrr::map2 and avoiding nested  for loops\nyou can loop over using a tuple using zip:  for (j, k) in zip([1 2 3], [4 5 6 7])\n1:5 syntax can be used like in R for indices\nYou can use \\epsilon or in ","category":"page"},{"location":"language/#Exception-Handling","page":"Language","title":"Exception Handling","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"There are a bunch of built-in exceptions: \nhere\nYou can define also: struct MyCustomException <: Exception\nThrow exceptions using throw(DomainError(x, \"argument is not part of domain\"))\nshowerror method on that error type allows you to define how that error  will be displayed\nstop() in R would be error throwing an ErrorException \ntry - catch - end is implemented like so:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"try \n  sqrt(\"ten\")\ncatch e # this e is the exception \n  println(\"Needs to be numeric not a string\")\nend ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"can do inline try catch using try condition catch e; expression end\nfinally can be added to ensure that things are finalized (close db or file  connections and whatnot).","category":"page"},{"location":"language/#Types","page":"Language","title":"Types","text":"","category":"section"},{"location":"language/#General-type-system","page":"Language","title":"General type system","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Julia's type system is ultimately dynamic but gains compiler advantages from type annotations.\nType annotations serve 3 purposes:\ntake advantage of Julia's powerful multiple-dispatch mechanism\nimprove human readability\ncatch programming errors\nWhy can't you inherit from a concrete type?\ninherit behavior (methods) more important than inheriting structure\nbut I mean why not both?\nthere are some difficulties with inheriting structure (? - unanswered)\nSalient aspects:\nNo divison between object and non-object values\nNo compile time type\nOnly values have types not variables","category":"page"},{"location":"language/#Type-declarations","page":"Language","title":"Type declarations","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":":: operator: \"is an instance of\"\n(1 + 2)::Int is a type assertion \nx::Int = 1 is a type restriction of that variable\nfunction sinc(x)::Float64 is a type restriction on the result","category":"page"},{"location":"language/#Abstract-types","page":"Language","title":"Abstract types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Cannot be instantiated\nabstract type «name» end\nDefault supertype is Any - all objects are instances of\nBottom type is Union{} nothins is a Union{} and all are supertypes\n<: is operator for \"is a subtype of\"","category":"page"},{"location":"language/#Primitive-types","page":"Language","title":"Primitive types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can declare these as bits but why?\nprimitive type <<name>> <: <<supertype>> <<bits>> end","category":"page"},{"location":"language/#Composite-Types","page":"Language","title":"Composite Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"composed of primitive types, called records or   structs or objects\nJulia composite types cannot have methods in them, the methods are outside\nBy default two constructors area created which is just a  function with the elements of the struct as arguments, and one that takes Any type and attempts to do the conversion.\nStructs are immutable (like pretty much anything in R except environments)  primarily for performance and secondarily for readability. They can be  made mutable using a mutable struct keyword though.\nHow do you decide whether a type can be immutable or not? Ask yourself if  two objects that have exactly the same fields are identical. If they are, it's usually an indicator that you want an immutable type.\nAll these declared types are of type DataType","category":"page"},{"location":"language/#Type-Unions","page":"Language","title":"Type Unions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You moosh together two types and anything inherits from that like so: IntOrString = Union{Int, AbstractString}\nUnion{T, Nothing} is essentially a nullable type because it can be the special value nothing.","category":"page"},{"location":"language/#Parametric-types","page":"Language","title":"Parametric types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can declare a parametric type like so:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"struct Point{T}\n  x::T\n  y::T\nend","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Point is also a type containing any of its parameterized equivalents as   subtypes.\nPoint{Float64} is not a subtype of Point{Real}, so in order to define a  method that allows dispatching on both, use this form: ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"function norm(p::Point{<:Real}) end ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Point{<:Real} is really just a Point that is a UnionAll of all the  subtypes of Real, which explains how it works. You can also do  Point{>:Int} to get all the supertypes of Int. \nIf you use the constructor in a way, it already defins the parameteric types, i.e. calling Point(1.0, 2.0) will generate a Point{Float64} automatically.\nYou can declare types as subtypes of parametric abstract types just like  any other type.","category":"page"},{"location":"language/#Tuple-Types","page":"Language","title":"Tuple Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Function arguments are tuples, which are really like immutable structs that  are parameterized by the type of each arugment, but some differences:\nTuple types can have any number of parameters \nTyple types are covariant, so Tuple(Int) is a subtype of Tuple(Any).\nTypes do not have field names and are accessed by index.\n(1, \"foo\", 2.5) is a tuple\nTuples may have Vararg{T, N} which can match 0 to N arguments (Inf if N is omitted. There is a convenience NTuple{N,T} to represent a Tuple that has N elements of type T.","category":"page"},{"location":"language/#Named-Tuple-types","page":"Language","title":"Named Tuple types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Is this the named list in R?\nIt has a tuple of symbols and a tuple of field types: `NamedTuple{(:a, :b), Tuple{Int64, String}}\nYou can use @NamedTuple to provide a more convenient struct-like syntax:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"@NamedTuple begin \n  a::Int\n  b::String \nend","category":"page"},{"location":"language/#UnionAll-Types","page":"Language","title":"UnionAll Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Array{<:Integer} is effectively Array{T} where T<:Integer.\nYou can short form a type definition using: Vector{T} = Array{T, 1}","category":"page"},{"location":"language/#Singleton-Types","page":"Language","title":"Singleton Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Immutable composite types with no fields: struct NoFields end","category":"page"},{"location":"language/#Operations-on-Types","page":"Language","title":"Operations on Types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"isa(x, y) or x <: y checks for subtypes\ntypeof() returns the type of its argument\nsupertype() returns the supertype of its argument","category":"page"},{"location":"language/#Custom-pretty-printing","page":"Language","title":"Custom pretty-printing","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Overload the show function: Base.show(io::IO, z::Polar)\nYou can also change the output based on the MIME type: Base.show(io::IO, ::MIME\"text/plain\", z::Polar{T})","category":"page"},{"location":"language/#Value-types","page":"Language","title":"Value types","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can dispatch on the actual value of a type using the Val keyword, but this is likely to be not idiomatic.","category":"page"},{"location":"language/#Methods","page":"Language","title":"Methods","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"To facilitate using many different implementations of the same concept  smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of  argument types and counts. ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"A \"function\" is \nan object that maps a tuple of argyuments to a return value or throws  an exception if no appropriate value can be returned.\na conceptual operation that may be abstract\nA \"method\" is \na specific concrete implementation or behavior of a fucntion.\na function defined is usually just one method\nEven if the concrete implementation is quite different, well designed dispatch will appear very coherent from the outside.\nMultiple dispatch (like R's S4 but more deliberately made lol)\nMost specific (lower on the type tree) will be used.\nAmbiguities in selecting most specific type raise an error.\nJust define a function but with type annotations and voila it's a method of  that function (already that's less typing than R)\nAll conversion in Julia is explicit (also different from R)\nUse methods(f) to figure out the methods attached to the generic\nNo type means the Any apex type.","category":"page"},{"location":"language/#Parametric-Methods","page":"Language","title":"Parametric Methods","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"you can also define methods like so: same_type(x::T, y::T) where {T} which  applies whenever both x and y are of the same type.\nYou can also constrain those parameters by doing where {T<:Real}","category":"page"},{"location":"language/#Redefining-methods","page":"Language","title":"Redefining methods","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You cannot immediately use new method definitions as soon as you defined them usually in the same expression; use Base.invokelatest(f) to get around this.","category":"page"},{"location":"language/#Design-patterns","page":"Language","title":"Design patterns","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Extracting the type parameter from a super-type - You can use this  method to extract the type inside a parameterized type:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"eltype(::Type{<:AbstractArray{T}}) where {T} = T","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Building a similar type with a different type parameter - Use  Base.similar to create a mutable array with the given element type and  size. Use Base.copyto! in order to always create a copy.\nIterated dispatch - You can dispatch first on the outer container then  continue down the dispatch tree (similar to single dispatch).\nTrait-based dispatch (Holy trait) - This stuff is really getting over my  head now haha. ","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\n# Base.IndexStyle(a, b) returns a trait that is going to return the best way \n# to index that particular set of parameters, and then you can just fall back \n# to the default implementation so you don't have to keep a tree.\nmap(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray)","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Output-type computation - Base.promote_type decides the output type  of the computation for the basic types. \nSeparate convert and kernel logic - to reduce compile time is to isolate the conversion logic and the computation. \nParametrically-constrained Varargs methods - use the same parameter in  the operated objected and the varargs so you can constrain the methods","category":"page"},{"location":"language/#Some-function-gotchas","page":"Language","title":"Some function gotchas","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Note: keyword arguments do not operate on multiple dispatch\nNote: default arguments are going to bne overridden if you specify a more  specific implementation afterwards.","category":"page"},{"location":"language/#Function-like-objects","page":"Language","title":"Function-like objects","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can turn a type into a function that operates!\nThis is very similar to R where functions are first class objects.","category":"page"},{"location":"language/#Empty-generic-functions","page":"Language","title":"Empty generic functions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Use this to define a specific interface: function emptyfunc end ","category":"page"},{"location":"language/#Method-design-and-the-avoidance-of-ambiguities","page":"Language","title":"Method design and the avoidance of ambiguities","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Ambiguities can be hard to deal, here are some alternatives to just deifining a more specific method:\nTuple and NTuple arguments - in the empty case they are ambiguous as  to type so you can either define one on empty type or restrain your NTuple arguments to only where N > 1\nOrthogonalized design - nest the methods\nDispatch on one argument at a time (Single dispatch)\nDon't define methods that dispatch on specific element types of  abstract containers, instead you should just define on a generic method and  construct a conceptual tree before specializing.\nWhen recursing avoid relying on default arguments because you can cause  an infinite loop.","category":"page"},{"location":"language/#Constructors","page":"Language","title":"Constructors","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"It's just an automatically generated function that accompanies a struct.\n\"Outer constructors\" - You can create new methods for it just like any other  function\nUse the same value for fields\nAdd default values\n\"Inner constructors\"\nneeded for 2 use cases:\nenforcing invariants (validations)\nensures that no object (if immutable) will violate the invariant\nyou can't enforce with outer constructors because ultimately they  must call an inner constructor\nallowing construction of self-referential objects\nfor recursive applications, you can call new without all the fields\nyou can create a self referential object like this\ndeclared inside the block of a type declaration\nspecial access to a local function called new that is the default  constructor","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"struct OrderedPair\n  x::Real\n  y::Real\n  OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\nend","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"above object is now constraint to strictly decreasing\nit does not enforce this if the struct is mutable, so only immutable  structs will have some sort of guarantee.\nBest practices for constructors:\nas few inner constructors as possible\ntake all arguments explicitly and enforce essential error checking\nprovide ocnveniences as outer construtors\nIncomplete initialization\nFor recursion\nParametric constructors\nUse the promote function heavily so that you can rationalize with only 1  type.","category":"page"},{"location":"language/#Conversion-and-Promotion","page":"Language","title":"Conversion and Promotion","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Two approaches to promotion:\nAutomatic promotion for built-ins (Perl, Python) \n1 + 1.5 is automatically promoted to floating point  \nNo automatic promotion\nquite inconvenient\nJulia falls into the no automatic promotion (#2) but implements some  polymorphic multiple dispatch as a special application. It can be edited by the user if they so choose and user-defined types can participate.","category":"page"},{"location":"language/#Conversion","page":"Language","title":"Conversion","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Just call the constructor on the object to be converted.\nconvert(::DataType, x) function is the function on which we add conversion methods.\nJulia does not aurtomatically convert between strings and numbers.\nConversion differs from construction in:\nMutable collections\nWhere it's not really a conversion\nWrapper types - types that wrap other value.\nConstructors that don't rteturn instances of their own type.","category":"page"},{"location":"language/#Defining-new-conversions","page":"Language","title":"Defining new conversions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"It's just a metter of defining a method for convert\nOnly do this if implicit conversion is safe! Otherwise, rely on the  constructor functions being explicitly called.","category":"page"},{"location":"language/#Promotion","page":"Language","title":"Promotion","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Standardization of types prior to an operation.\nHandled by the promote() method - but you don't define the rules on  promote but on the promote_rule(::DataType, ::DataType) which doesn't take the actual values but the datatypes. This is symmetric already so you don't need to define the flipped datatypes. This feeds into a function called promote_type that you can then use to actually determine what type the  value will end up being.\nAiming to be as lossless as possible.","category":"page"},{"location":"language/#Interfaces","page":"Language","title":"Interfaces","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Iteration interface\ndefining an iterate method will allow you to use \nfor loops\nin operator\nmean, std etc\ndefining eltype method will allow us to know more things like creating specialized iterable code that's faster\ndefining length allows us to preallocate and stuff like that\ndefining firstindex and lastindex allow us to specify the first and  last valid indices so we can use the begin and end indices\nAbstractArray interface\nIndexStyle is important to define for efficiency\nThis interface is extremely rich, simply defining: struct SquaresVector <: AbstractArray{Int, 1} is enough to make it  iterable, indexable, and completely functional.\nStrided Arrays - a lot over my head\nCustomizing broadcasting - also over my head but I can see how that can be  super useful for building actual machine learning models.","category":"page"},{"location":"language/#Modules","page":"Language","title":"Modules","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"would be the whole package scope in an R package I suppose\nkey properties are: \nseparate namespaces - avoids conflicts in function names\nhas import and export for defining what it needs and what it provides other modules (by default, there is no private namespace)\nModules can be precompiled for faster loading and contain code for  running initialization.\nmodule code is typically organized into files and then read in using  include(\"file1.jl\"). \nalthough related include is just adding the code in the file into wherever  it is and modules can be composed around or within that any which way.\nparentmodule finds the module that an object is contained\nYou can reserve variable names by declaring global x so that it cannot be  modified from outside the module.\nusing loads all exports into the Main namespace, whereas import just brings the module name into scope, so you'd need to quality everything in  there in order to use it. \nusing Module: name1, name2 only brings specific names into global scope and the module name will not be in scope unless you also include it in  the names list. You can't add methods to a function without a namespace  (as it's \"using\")\nimport Module: name1, name2 brings in the specific names and also  allows you to attach methods (usually done in other modules)\nYou can use as to work around namespace conflicts like  import CSV: read as rd or importBenchmarkTools as BT. This is not  compatible with using/.\nWhen modules export the same name:\nUse qualified name especially when they mean different things\nuse the keyword to reanme one or both with unqiue identifiers.\nIf they do share the same meaning then there is a unifier base package.\nBase and Core are in the modules unless you define baremodule\nimport .Module imports a module defined in the current scope,  import ..Module imports a module defined in the parent module and so on. .. is essentially a \"sibling\" module.","category":"page"},{"location":"language/#Module-initialization-and-pre-compilation","page":"Language","title":"Module initialization and pre-compilation","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Whenever something is import-ed or using-ed the modulem is precompiled. Trigger manually using Base.compilecache\nPut __precompile__(false) in the module file at the top to prevent a module from being precompiled. \nDon't precompile any external dependencies but rather define them at  runtime using the __init__() function, like external C libraries and global  constants that containe pointers returned by external library\nDictionaries can be safe to precompile if the key is generally standard types, not weird ones like Function or DataType or user-defined types without  a defined hash method.","category":"page"},{"location":"language/#Documentation","page":"Language","title":"Documentation","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Docstrings basically, interpreted as Markdown handled by Markdown.jl.\nStandard for a docstring:","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"\"\"\"\n    bar(x[, y]) # function signature with indent, optional with [], kwargs with ;\n  \nImperative format of title ending with a period.\n\nAdditional details in a second paragraph that explains more implem details. Be \nconcise and don't repeat yourself. \n\n# Arguments \n\nThis part is only necessary if it's a complex function and those with kwargs.\n\nSee also: [`bar!`](@ref) # Hints to related functions \n\n# Examples\n\nWritten as doctests whenever possible\n\n\\```jldoctest \njulia> code to run\noutput that matches the output exactly. Use [...] to truncate the output.\n\\```\n\"\"\"","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"code and LATEX\n92 characters wide max\nFunction implementation for custom types can be in an Implementation section. Intended for developers rather than users.\nLong docstrings can be split off to an extended help header tahn can be  called explicitly by adding ??function rather than ?function\nIdeally only the generic function needs to be documented, no need to  document the individual methods, unless the behavior differs explicitly.\n@doc macro allows you to insert expressions into the documentation. \nUse $($name) to use string interpolation in docstrings\nYou can define a method on Docs.getdoc to be able to operate on that  type and access the data for it.\nIf you alias something, just document the original so that both can have  the documentation.\nYou can add a docstring to two things separated by a comma.","category":"page"},{"location":"language/#Metaprogamming","page":"Language","title":"Metaprogamming","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"Now this is going to be exciting!\nAll this (including R) inherits from Lisp.\nExpressions have two parts (type Expr, Expr(:call, :+, 1, 1))\nhead: indicating the type of expression - exp.head\nargs: the contents of the expression - exp.args\nExpressions can be nested and manipulated\nSymbols are represented as :symbol\nSymbol(\"func\", 10) turns into func10 so you can manipulate the  symbol with strings.\nQuoting\ncreation of expression objects \n:(a + b * c + 1) turns the quote string into an expression \nInterpolation\nmanipulating the expression objects without Expr using $\nex = :($a + b) turns into :(1 + b) because a is evaluiated and  a = 1.\nYou can also do splatting interpolation through $(xs...).  :(f(1, $(args...))) turns into :(f(1, x, y, z))\nthe $ is kinda like !! in R and the splatted one is !!!\nYou can nest down levels of quoting through $$$....\nQuoteNode avoids interpolating the :$\nEvaluation\nYou can execute the expression using eval\nModule.eval evaluates inside the global scope of the Module\nYou can define functions that manipulate these expressions\nMacros\nincluding generated code in the final body of a program\nmaps a tuple of arguments to a returned expression which is compiled  directly instead of at runtime\nThink of the result of the macro being inlined into the code by the  compiler and then that being compiled.\nInspect the expressiong using macroexpand \nmacroexpand(Main, :(@sayhello \"Troy\")) - you need to include  the module in which the macro will be evaluated.\nMacros receive the __source__ and __module__ argumens which contain  the line number of the invocation and the information about the expansion  module (like existing bindings).\nMacros rename local variabels to avoid name clashes with the module scope. You can use esc(ex) to escape this and ignore hygiene.\nMacros are also functions and can therefore take advantage of multiple dispatch, but they dispatch based on types of the AST not the evaluated values of the expressions","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"macro sayhello()\n  return :( println(\"Hello there!\") )\nend","category":"page"},{"location":"language/","page":"Language","title":"Language","text":"Boilerplate code can be generated programmatically using eval on a  quote ... end with interpolation. You can use the eval/quote pattern using the @eval macro","category":"page"},{"location":"language/#Non-standard-string-literals","page":"Language","title":"Non-standard string literals","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can define string literals like r\"^\\s\" which is a regex or b\"...\"  which is a byte array literal.\nYou can also take advantage of this by defining a macros that is of the form  {...}_str which allows you to define a string literal {...}\"...\".","category":"page"},{"location":"language/#Generated-functions","page":"Language","title":"Generated functions","text":"","category":"section"},{"location":"language/","page":"Language","title":"Language","text":"You can define using @generated and the function should return a quoted expression. \nI don't get this at all haha\nThere's also optionally generated functions.","category":"page"},{"location":"blogging/#Blogging-/-Publishing","page":"Blogging","title":"Blogging / Publishing","text":"","category":"section"},{"location":"blogging/#Franklin.jl","page":"Blogging","title":"Franklin.jl","text":"","category":"section"},{"location":"blogging/","page":"Blogging","title":"Blogging","text":"I really like the {distill} package in R, maybe I can contribute a Distill theme for Franklin!","category":"page"},{"location":"computation/#Computation","page":"Computation","title":"Computation","text":"","category":"section"},{"location":"computation/#Dagger.jl","page":"Computation","title":"Dagger.jl","text":"","category":"section"},{"location":"computation/#Distributed.jl-and-Ecosystem","page":"Computation","title":"Distributed.jl and Ecosystem","text":"","category":"section"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Using: Documenter.jl","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"I'm interested to see how well we can document stuff, and I'm going to  mainly use the package documentation feature to document my findings during this exploration.\nSeems pretty good so far! I really like the freeformness of the documentation that we can link to docstrings and such. R's documentation system via  {roxygen2} is more restrictive and sometimes requires me to add a lot of  boilerplate. This one feels just right.\nOther packages have very scant package documentation. This is an opportunity to start contributing!","category":"page"},{"location":"orm/#Object-Relational-Mapping","page":"Object-Relational Mapping","title":"Object-Relational Mapping","text":"","category":"section"},{"location":"orm/","page":"Object-Relational Mapping","title":"Object-Relational Mapping","text":"Using: Stipple.jl, Octo.jl","category":"page"},{"location":"dataframes/#Data-Frames","page":"Data Frames","title":"Data Frames","text":"","category":"section"},{"location":"dataframes/","page":"Data Frames","title":"Data Frames","text":"I'm mainly coming at this from a Data Science and Backend systems point of view, so data frames are going to be hugely important.","category":"page"},{"location":"python/#Python-interoperability","page":"Python","title":"Python interoperability","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"I want to be able ot manage environments and use packages in Python as binaries, not necessarily requiring such a deep integration.","category":"page"},{"location":"python/#Conda.jl","page":"Python","title":"Conda.jl","text":"","category":"section"},{"location":"#LearningJulia.jl","page":"Introduction","title":"LearningJulia.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is just a container for all the code I write while trying to  learn the Julia language.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"I'm just writing bullet points and notes as a stream-of-consciousness, so  this won't be particularly organized, but hopefully this will help other R  users coming to Julia on what to watch out for and how well it might map to similar workflows.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Depth = 1","category":"page"}]
}
